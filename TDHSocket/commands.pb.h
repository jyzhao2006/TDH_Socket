// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: commands.proto

#ifndef PROTOBUF_commands_2eproto__INCLUDED
#define PROTOBUF_commands_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/service.h>
// @@protoc_insertion_point(includes)

namespace protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_commands_2eproto();
void protobuf_AssignDesc_commands_2eproto();
void protobuf_ShutdownFile_commands_2eproto();

class Value;
class Expression;
class Function;
class ValuesArray;
class ColumnsArray;
class Column;
class OrderBy;
class ResultSet;
class ExtraMsg;
class QueryCommon;
class Put;
class Filter;
class CommandNode;
class CommandRequest;
class ResultSetRequest;
class TransactionRequest;
class LoginRequest;
class PingRequest;

enum Column_AGGREGATE_FUNC {
  Column_AGGREGATE_FUNC_COUNT = 1,
  Column_AGGREGATE_FUNC_SUM = 2,
  Column_AGGREGATE_FUNC_MAX = 3,
  Column_AGGREGATE_FUNC_MIN = 4,
  Column_AGGREGATE_FUNC_AVG = 5
};
bool Column_AGGREGATE_FUNC_IsValid(int value);
const Column_AGGREGATE_FUNC Column_AGGREGATE_FUNC_AGGREGATE_FUNC_MIN = Column_AGGREGATE_FUNC_COUNT;
const Column_AGGREGATE_FUNC Column_AGGREGATE_FUNC_AGGREGATE_FUNC_MAX = Column_AGGREGATE_FUNC_AVG;
const int Column_AGGREGATE_FUNC_AGGREGATE_FUNC_ARRAYSIZE = Column_AGGREGATE_FUNC_AGGREGATE_FUNC_MAX + 1;

const ::google::protobuf::EnumDescriptor* Column_AGGREGATE_FUNC_descriptor();
inline const ::std::string& Column_AGGREGATE_FUNC_Name(Column_AGGREGATE_FUNC value) {
  return ::google::protobuf::internal::NameOfEnum(
    Column_AGGREGATE_FUNC_descriptor(), value);
}
inline bool Column_AGGREGATE_FUNC_Parse(
    const ::std::string& name, Column_AGGREGATE_FUNC* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Column_AGGREGATE_FUNC>(
    Column_AGGREGATE_FUNC_descriptor(), name, value);
}
enum Column_ValueType {
  Column_ValueType_LONG_VAL = 1,
  Column_ValueType_SHORT_VAL = 2,
  Column_ValueType_BOOLEAN_VAL = 3,
  Column_ValueType_CHAR_VAL = 4,
  Column_ValueType_STRING_VAL = 5,
  Column_ValueType_FLOAT_VAL = 6,
  Column_ValueType_DOUBLE_VAL = 7,
  Column_ValueType_INT_VAL = 8,
  Column_ValueType_BIND_VAL = 9,
  Column_ValueType_DATE_VAL = 10,
  Column_ValueType_BYTES_VAL = 11,
  Column_ValueType_TIMESTAMP = 12
};
bool Column_ValueType_IsValid(int value);
const Column_ValueType Column_ValueType_ValueType_MIN = Column_ValueType_LONG_VAL;
const Column_ValueType Column_ValueType_ValueType_MAX = Column_ValueType_TIMESTAMP;
const int Column_ValueType_ValueType_ARRAYSIZE = Column_ValueType_ValueType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Column_ValueType_descriptor();
inline const ::std::string& Column_ValueType_Name(Column_ValueType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Column_ValueType_descriptor(), value);
}
inline bool Column_ValueType_Parse(
    const ::std::string& name, Column_ValueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Column_ValueType>(
    Column_ValueType_descriptor(), name, value);
}
enum OrderBy_DIRECTION {
  OrderBy_DIRECTION_ASC = 1,
  OrderBy_DIRECTION_DESC = 2
};
bool OrderBy_DIRECTION_IsValid(int value);
const OrderBy_DIRECTION OrderBy_DIRECTION_DIRECTION_MIN = OrderBy_DIRECTION_ASC;
const OrderBy_DIRECTION OrderBy_DIRECTION_DIRECTION_MAX = OrderBy_DIRECTION_DESC;
const int OrderBy_DIRECTION_DIRECTION_ARRAYSIZE = OrderBy_DIRECTION_DIRECTION_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderBy_DIRECTION_descriptor();
inline const ::std::string& OrderBy_DIRECTION_Name(OrderBy_DIRECTION value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderBy_DIRECTION_descriptor(), value);
}
inline bool OrderBy_DIRECTION_Parse(
    const ::std::string& name, OrderBy_DIRECTION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderBy_DIRECTION>(
    OrderBy_DIRECTION_descriptor(), name, value);
}
enum QueryCommon_QUERY_CONCURRENCY {
  QueryCommon_QUERY_CONCURRENCY_SEQUENTIAL = 1,
  QueryCommon_QUERY_CONCURRENCY_CONCURRENT = 2
};
bool QueryCommon_QUERY_CONCURRENCY_IsValid(int value);
const QueryCommon_QUERY_CONCURRENCY QueryCommon_QUERY_CONCURRENCY_QUERY_CONCURRENCY_MIN = QueryCommon_QUERY_CONCURRENCY_SEQUENTIAL;
const QueryCommon_QUERY_CONCURRENCY QueryCommon_QUERY_CONCURRENCY_QUERY_CONCURRENCY_MAX = QueryCommon_QUERY_CONCURRENCY_CONCURRENT;
const int QueryCommon_QUERY_CONCURRENCY_QUERY_CONCURRENCY_ARRAYSIZE = QueryCommon_QUERY_CONCURRENCY_QUERY_CONCURRENCY_MAX + 1;

const ::google::protobuf::EnumDescriptor* QueryCommon_QUERY_CONCURRENCY_descriptor();
inline const ::std::string& QueryCommon_QUERY_CONCURRENCY_Name(QueryCommon_QUERY_CONCURRENCY value) {
  return ::google::protobuf::internal::NameOfEnum(
    QueryCommon_QUERY_CONCURRENCY_descriptor(), value);
}
inline bool QueryCommon_QUERY_CONCURRENCY_Parse(
    const ::std::string& name, QueryCommon_QUERY_CONCURRENCY* value) {
  return ::google::protobuf::internal::ParseNamedEnum<QueryCommon_QUERY_CONCURRENCY>(
    QueryCommon_QUERY_CONCURRENCY_descriptor(), name, value);
}
enum QueryCommon_PlanType {
  QueryCommon_PlanType_NEST_LOOP_JOIN = 1,
  QueryCommon_PlanType_SORT_MERGE_JOIN = 2,
  QueryCommon_PlanType_HASH_JOIN = 3,
  QueryCommon_PlanType_QUERY = 4,
  QueryCommon_PlanType_INDEX_NEST_LOOP = 6,
  QueryCommon_PlanType_MERGE = 7
};
bool QueryCommon_PlanType_IsValid(int value);
const QueryCommon_PlanType QueryCommon_PlanType_PlanType_MIN = QueryCommon_PlanType_NEST_LOOP_JOIN;
const QueryCommon_PlanType QueryCommon_PlanType_PlanType_MAX = QueryCommon_PlanType_MERGE;
const int QueryCommon_PlanType_PlanType_ARRAYSIZE = QueryCommon_PlanType_PlanType_MAX + 1;

const ::google::protobuf::EnumDescriptor* QueryCommon_PlanType_descriptor();
inline const ::std::string& QueryCommon_PlanType_Name(QueryCommon_PlanType value) {
  return ::google::protobuf::internal::NameOfEnum(
    QueryCommon_PlanType_descriptor(), value);
}
inline bool QueryCommon_PlanType_Parse(
    const ::std::string& name, QueryCommon_PlanType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<QueryCommon_PlanType>(
    QueryCommon_PlanType_descriptor(), name, value);
}
enum QueryCommon_LockModel {
  QueryCommon_LockModel_SHARED_LOCK = 1,
  QueryCommon_LockModel_EXCLUSIVE_LOCK = 2
};
bool QueryCommon_LockModel_IsValid(int value);
const QueryCommon_LockModel QueryCommon_LockModel_LockModel_MIN = QueryCommon_LockModel_SHARED_LOCK;
const QueryCommon_LockModel QueryCommon_LockModel_LockModel_MAX = QueryCommon_LockModel_EXCLUSIVE_LOCK;
const int QueryCommon_LockModel_LockModel_ARRAYSIZE = QueryCommon_LockModel_LockModel_MAX + 1;

const ::google::protobuf::EnumDescriptor* QueryCommon_LockModel_descriptor();
inline const ::std::string& QueryCommon_LockModel_Name(QueryCommon_LockModel value) {
  return ::google::protobuf::internal::NameOfEnum(
    QueryCommon_LockModel_descriptor(), value);
}
inline bool QueryCommon_LockModel_Parse(
    const ::std::string& name, QueryCommon_LockModel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<QueryCommon_LockModel>(
    QueryCommon_LockModel_descriptor(), name, value);
}
enum Put_PUT_TYPE {
  Put_PUT_TYPE_REPLACE = 1,
  Put_PUT_TYPE_INSERT = 2,
  Put_PUT_TYPE_DELETE = 3,
  Put_PUT_TYPE_UPDATE = 4
};
bool Put_PUT_TYPE_IsValid(int value);
const Put_PUT_TYPE Put_PUT_TYPE_PUT_TYPE_MIN = Put_PUT_TYPE_REPLACE;
const Put_PUT_TYPE Put_PUT_TYPE_PUT_TYPE_MAX = Put_PUT_TYPE_UPDATE;
const int Put_PUT_TYPE_PUT_TYPE_ARRAYSIZE = Put_PUT_TYPE_PUT_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* Put_PUT_TYPE_descriptor();
inline const ::std::string& Put_PUT_TYPE_Name(Put_PUT_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    Put_PUT_TYPE_descriptor(), value);
}
inline bool Put_PUT_TYPE_Parse(
    const ::std::string& name, Put_PUT_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Put_PUT_TYPE>(
    Put_PUT_TYPE_descriptor(), name, value);
}
enum Filter_AccessType {
  Filter_AccessType_AND = 1,
  Filter_AccessType_OR = 2,
  Filter_AccessType_GT = 3,
  Filter_AccessType_LT = 4,
  Filter_AccessType_GT_EQ = 5,
  Filter_AccessType_LT_EQ = 6,
  Filter_AccessType_EQ = 7,
  Filter_AccessType_LIKE = 8,
  Filter_AccessType_IS_NULL = 9,
  Filter_AccessType_IS_NOT_NULL = 10,
  Filter_AccessType_NOT_EQ = 11,
  Filter_AccessType_IN = 12,
  Filter_AccessType_IS = 13,
  Filter_AccessType_CONSTANT = 14,
  Filter_AccessType_NULL_SAFE_EQUAL = 15
};
bool Filter_AccessType_IsValid(int value);
const Filter_AccessType Filter_AccessType_AccessType_MIN = Filter_AccessType_AND;
const Filter_AccessType Filter_AccessType_AccessType_MAX = Filter_AccessType_NULL_SAFE_EQUAL;
const int Filter_AccessType_AccessType_ARRAYSIZE = Filter_AccessType_AccessType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Filter_AccessType_descriptor();
inline const ::std::string& Filter_AccessType_Name(Filter_AccessType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Filter_AccessType_descriptor(), value);
}
inline bool Filter_AccessType_Parse(
    const ::std::string& name, Filter_AccessType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Filter_AccessType>(
    Filter_AccessType_descriptor(), name, value);
}
// ===================================================================

class Value : public ::google::protobuf::Message {
 public:
  Value();
  virtual ~Value();
  
  Value(const Value& from);
  
  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Value& default_instance();
  
  void Swap(Value* other);
  
  // implements Message ----------------------------------------------
  
  Value* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 integerVal = 2;
  inline bool has_integerval() const;
  inline void clear_integerval();
  static const int kIntegerValFieldNumber = 2;
  inline ::google::protobuf::int32 integerval() const;
  inline void set_integerval(::google::protobuf::int32 value);
  
  // optional int64 longVal = 3;
  inline bool has_longval() const;
  inline void clear_longval();
  static const int kLongValFieldNumber = 3;
  inline ::google::protobuf::int64 longval() const;
  inline void set_longval(::google::protobuf::int64 value);
  
  // optional bool boolVal = 4;
  inline bool has_boolval() const;
  inline void clear_boolval();
  static const int kBoolValFieldNumber = 4;
  inline bool boolval() const;
  inline void set_boolval(bool value);
  
  // optional string stringVal = 5;
  inline bool has_stringval() const;
  inline void clear_stringval();
  static const int kStringValFieldNumber = 5;
  inline const ::std::string& stringval() const;
  inline void set_stringval(const ::std::string& value);
  inline void set_stringval(const char* value);
  inline void set_stringval(const char* value, size_t size);
  inline ::std::string* mutable_stringval();
  
  // optional double doubleVal = 6;
  inline bool has_doubleval() const;
  inline void clear_doubleval();
  static const int kDoubleValFieldNumber = 6;
  inline double doubleval() const;
  inline void set_doubleval(double value);
  
  // optional float floatVal = 7;
  inline bool has_floatval() const;
  inline void clear_floatval();
  static const int kFloatValFieldNumber = 7;
  inline float floatval() const;
  inline void set_floatval(float value);
  
  // optional string charVal = 8;
  inline bool has_charval() const;
  inline void clear_charval();
  static const int kCharValFieldNumber = 8;
  inline const ::std::string& charval() const;
  inline void set_charval(const ::std::string& value);
  inline void set_charval(const char* value);
  inline void set_charval(const char* value, size_t size);
  inline ::std::string* mutable_charval();
  
  // optional int32 bindVal = 9;
  inline bool has_bindval() const;
  inline void clear_bindval();
  static const int kBindValFieldNumber = 9;
  inline ::google::protobuf::int32 bindval() const;
  inline void set_bindval(::google::protobuf::int32 value);
  
  // optional int64 dateVal = 10;
  inline bool has_dateval() const;
  inline void clear_dateval();
  static const int kDateValFieldNumber = 10;
  inline ::google::protobuf::int64 dateval() const;
  inline void set_dateval(::google::protobuf::int64 value);
  
  // optional bool null = 11;
  inline bool has_null() const;
  inline void clear_null();
  static const int kNullFieldNumber = 11;
  inline bool null() const;
  inline void set_null(bool value);
  
  // @@protoc_insertion_point(class_scope:protobuf.Value)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 integerval_;
  ::google::protobuf::int64 longval_;
  bool boolval_;
  ::std::string* stringval_;
  static const ::std::string _default_stringval_;
  double doubleval_;
  float floatval_;
  ::std::string* charval_;
  static const ::std::string _default_charval_;
  ::google::protobuf::int32 bindval_;
  ::google::protobuf::int64 dateval_;
  bool null_;
  friend void  protobuf_AddDesc_commands_2eproto();
  friend void protobuf_AssignDesc_commands_2eproto();
  friend void protobuf_ShutdownFile_commands_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Value* default_instance_;
};
// -------------------------------------------------------------------

class Expression : public ::google::protobuf::Message {
 public:
  Expression();
  virtual ~Expression();
  
  Expression(const Expression& from);
  
  inline Expression& operator=(const Expression& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression& default_instance();
  
  void Swap(Expression* other);
  
  // implements Message ----------------------------------------------
  
  Expression* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Expression& from);
  void MergeFrom(const Expression& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .protobuf.Column column = 1;
  inline bool has_column() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 1;
  inline const ::protobuf::Column& column() const;
  inline ::protobuf::Column* mutable_column();
  
  // optional .protobuf.Value value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::protobuf::Value& value() const;
  inline ::protobuf::Value* mutable_value();
  
  // optional .protobuf.Function function = 3;
  inline bool has_function() const;
  inline void clear_function();
  static const int kFunctionFieldNumber = 3;
  inline const ::protobuf::Function& function() const;
  inline ::protobuf::Function* mutable_function();
  
  // @@protoc_insertion_point(class_scope:protobuf.Expression)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::protobuf::Column* column_;
  ::protobuf::Value* value_;
  ::protobuf::Function* function_;
  friend void  protobuf_AddDesc_commands_2eproto();
  friend void protobuf_AssignDesc_commands_2eproto();
  friend void protobuf_ShutdownFile_commands_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Expression* default_instance_;
};
// -------------------------------------------------------------------

class Function : public ::google::protobuf::Message {
 public:
  Function();
  virtual ~Function();
  
  Function(const Function& from);
  
  inline Function& operator=(const Function& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Function& default_instance();
  
  void Swap(Function* other);
  
  // implements Message ----------------------------------------------
  
  Function* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Function& from);
  void MergeFrom(const Function& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string functionName = 1;
  inline bool has_functionname() const;
  inline void clear_functionname();
  static const int kFunctionNameFieldNumber = 1;
  inline const ::std::string& functionname() const;
  inline void set_functionname(const ::std::string& value);
  inline void set_functionname(const char* value);
  inline void set_functionname(const char* value, size_t size);
  inline ::std::string* mutable_functionname();
  
  // repeated .protobuf.Expression expression = 2;
  inline int expression_size() const;
  inline void clear_expression();
  static const int kExpressionFieldNumber = 2;
  inline const ::protobuf::Expression& expression(int index) const;
  inline ::protobuf::Expression* mutable_expression(int index);
  inline ::protobuf::Expression* add_expression();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >&
      expression() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >*
      mutable_expression();
  
  // optional string alias = 3;
  inline bool has_alias() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 3;
  inline const ::std::string& alias() const;
  inline void set_alias(const ::std::string& value);
  inline void set_alias(const char* value);
  inline void set_alias(const char* value, size_t size);
  inline ::std::string* mutable_alias();
  
  // optional bool distinct = 4;
  inline bool has_distinct() const;
  inline void clear_distinct();
  static const int kDistinctFieldNumber = 4;
  inline bool distinct() const;
  inline void set_distinct(bool value);
  
  // optional string tableName = 5;
  inline bool has_tablename() const;
  inline void clear_tablename();
  static const int kTableNameFieldNumber = 5;
  inline const ::std::string& tablename() const;
  inline void set_tablename(const ::std::string& value);
  inline void set_tablename(const char* value);
  inline void set_tablename(const char* value, size_t size);
  inline ::std::string* mutable_tablename();
  
  // optional string columnName = 6;
  inline bool has_columnname() const;
  inline void clear_columnname();
  static const int kColumnNameFieldNumber = 6;
  inline const ::std::string& columnname() const;
  inline void set_columnname(const ::std::string& value);
  inline void set_columnname(const char* value);
  inline void set_columnname(const char* value, size_t size);
  inline ::std::string* mutable_columnname();
  
  // optional bool isNot = 7;
  inline bool has_isnot() const;
  inline void clear_isnot();
  static const int kIsNotFieldNumber = 7;
  inline bool isnot() const;
  inline void set_isnot(bool value);
  
  // @@protoc_insertion_point(class_scope:protobuf.Function)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* functionname_;
  static const ::std::string _default_functionname_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::Expression > expression_;
  ::std::string* alias_;
  static const ::std::string _default_alias_;
  bool distinct_;
  ::std::string* tablename_;
  static const ::std::string _default_tablename_;
  ::std::string* columnname_;
  static const ::std::string _default_columnname_;
  bool isnot_;
  friend void  protobuf_AddDesc_commands_2eproto();
  friend void protobuf_AssignDesc_commands_2eproto();
  friend void protobuf_ShutdownFile_commands_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Function* default_instance_;
};
// -------------------------------------------------------------------

class ValuesArray : public ::google::protobuf::Message {
 public:
  ValuesArray();
  virtual ~ValuesArray();
  
  ValuesArray(const ValuesArray& from);
  
  inline ValuesArray& operator=(const ValuesArray& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ValuesArray& default_instance();
  
  void Swap(ValuesArray* other);
  
  // implements Message ----------------------------------------------
  
  ValuesArray* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ValuesArray& from);
  void MergeFrom(const ValuesArray& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .protobuf.Value values = 1;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 1;
  inline const ::protobuf::Value& values(int index) const;
  inline ::protobuf::Value* mutable_values(int index);
  inline ::protobuf::Value* add_values();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::Value >&
      values() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::Value >*
      mutable_values();
  
  // optional bool empty = 2;
  inline bool has_empty() const;
  inline void clear_empty();
  static const int kEmptyFieldNumber = 2;
  inline bool empty() const;
  inline void set_empty(bool value);
  
  // @@protoc_insertion_point(class_scope:protobuf.ValuesArray)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::protobuf::Value > values_;
  bool empty_;
  friend void  protobuf_AddDesc_commands_2eproto();
  friend void protobuf_AssignDesc_commands_2eproto();
  friend void protobuf_ShutdownFile_commands_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ValuesArray* default_instance_;
};
// -------------------------------------------------------------------

class ColumnsArray : public ::google::protobuf::Message {
 public:
  ColumnsArray();
  virtual ~ColumnsArray();
  
  ColumnsArray(const ColumnsArray& from);
  
  inline ColumnsArray& operator=(const ColumnsArray& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnsArray& default_instance();
  
  void Swap(ColumnsArray* other);
  
  // implements Message ----------------------------------------------
  
  ColumnsArray* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ColumnsArray& from);
  void MergeFrom(const ColumnsArray& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .protobuf.Column columns = 1;
  inline int columns_size() const;
  inline void clear_columns();
  static const int kColumnsFieldNumber = 1;
  inline const ::protobuf::Column& columns(int index) const;
  inline ::protobuf::Column* mutable_columns(int index);
  inline ::protobuf::Column* add_columns();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::Column >&
      columns() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::Column >*
      mutable_columns();
  
  // @@protoc_insertion_point(class_scope:protobuf.ColumnsArray)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::protobuf::Column > columns_;
  friend void  protobuf_AddDesc_commands_2eproto();
  friend void protobuf_AssignDesc_commands_2eproto();
  friend void protobuf_ShutdownFile_commands_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ColumnsArray* default_instance_;
};
// -------------------------------------------------------------------

class Column : public ::google::protobuf::Message {
 public:
  Column();
  virtual ~Column();
  
  Column(const Column& from);
  
  inline Column& operator=(const Column& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Column& default_instance();
  
  void Swap(Column* other);
  
  // implements Message ----------------------------------------------
  
  Column* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Column& from);
  void MergeFrom(const Column& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Column_AGGREGATE_FUNC AGGREGATE_FUNC;
  static const AGGREGATE_FUNC COUNT = Column_AGGREGATE_FUNC_COUNT;
  static const AGGREGATE_FUNC SUM = Column_AGGREGATE_FUNC_SUM;
  static const AGGREGATE_FUNC MAX = Column_AGGREGATE_FUNC_MAX;
  static const AGGREGATE_FUNC MIN = Column_AGGREGATE_FUNC_MIN;
  static const AGGREGATE_FUNC AVG = Column_AGGREGATE_FUNC_AVG;
  static inline bool AGGREGATE_FUNC_IsValid(int value) {
    return Column_AGGREGATE_FUNC_IsValid(value);
  }
  static const AGGREGATE_FUNC AGGREGATE_FUNC_MIN =
    Column_AGGREGATE_FUNC_AGGREGATE_FUNC_MIN;
  static const AGGREGATE_FUNC AGGREGATE_FUNC_MAX =
    Column_AGGREGATE_FUNC_AGGREGATE_FUNC_MAX;
  static const int AGGREGATE_FUNC_ARRAYSIZE =
    Column_AGGREGATE_FUNC_AGGREGATE_FUNC_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AGGREGATE_FUNC_descriptor() {
    return Column_AGGREGATE_FUNC_descriptor();
  }
  static inline const ::std::string& AGGREGATE_FUNC_Name(AGGREGATE_FUNC value) {
    return Column_AGGREGATE_FUNC_Name(value);
  }
  static inline bool AGGREGATE_FUNC_Parse(const ::std::string& name,
      AGGREGATE_FUNC* value) {
    return Column_AGGREGATE_FUNC_Parse(name, value);
  }
  
  typedef Column_ValueType ValueType;
  static const ValueType LONG_VAL = Column_ValueType_LONG_VAL;
  static const ValueType SHORT_VAL = Column_ValueType_SHORT_VAL;
  static const ValueType BOOLEAN_VAL = Column_ValueType_BOOLEAN_VAL;
  static const ValueType CHAR_VAL = Column_ValueType_CHAR_VAL;
  static const ValueType STRING_VAL = Column_ValueType_STRING_VAL;
  static const ValueType FLOAT_VAL = Column_ValueType_FLOAT_VAL;
  static const ValueType DOUBLE_VAL = Column_ValueType_DOUBLE_VAL;
  static const ValueType INT_VAL = Column_ValueType_INT_VAL;
  static const ValueType BIND_VAL = Column_ValueType_BIND_VAL;
  static const ValueType DATE_VAL = Column_ValueType_DATE_VAL;
  static const ValueType BYTES_VAL = Column_ValueType_BYTES_VAL;
  static const ValueType TIMESTAMP = Column_ValueType_TIMESTAMP;
  static inline bool ValueType_IsValid(int value) {
    return Column_ValueType_IsValid(value);
  }
  static const ValueType ValueType_MIN =
    Column_ValueType_ValueType_MIN;
  static const ValueType ValueType_MAX =
    Column_ValueType_ValueType_MAX;
  static const int ValueType_ARRAYSIZE =
    Column_ValueType_ValueType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ValueType_descriptor() {
    return Column_ValueType_descriptor();
  }
  static inline const ::std::string& ValueType_Name(ValueType value) {
    return Column_ValueType_Name(value);
  }
  static inline bool ValueType_Parse(const ::std::string& name,
      ValueType* value) {
    return Column_ValueType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string columnName = 1;
  inline bool has_columnname() const;
  inline void clear_columnname();
  static const int kColumnNameFieldNumber = 1;
  inline const ::std::string& columnname() const;
  inline void set_columnname(const ::std::string& value);
  inline void set_columnname(const char* value);
  inline void set_columnname(const char* value, size_t size);
  inline ::std::string* mutable_columnname();
  
  // optional .protobuf.Column.ValueType valueType = 2;
  inline bool has_valuetype() const;
  inline void clear_valuetype();
  static const int kValueTypeFieldNumber = 2;
  inline ::protobuf::Column_ValueType valuetype() const;
  inline void set_valuetype(::protobuf::Column_ValueType value);
  
  // optional .protobuf.Column.AGGREGATE_FUNC aggegateFunction = 3;
  inline bool has_aggegatefunction() const;
  inline void clear_aggegatefunction();
  static const int kAggegateFunctionFieldNumber = 3;
  inline ::protobuf::Column_AGGREGATE_FUNC aggegatefunction() const;
  inline void set_aggegatefunction(::protobuf::Column_AGGREGATE_FUNC value);
  
  // optional string alias = 4;
  inline bool has_alias() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 4;
  inline const ::std::string& alias() const;
  inline void set_alias(const ::std::string& value);
  inline void set_alias(const char* value);
  inline void set_alias(const char* value, size_t size);
  inline ::std::string* mutable_alias();
  
  // optional bool distinct = 5;
  inline bool has_distinct() const;
  inline void clear_distinct();
  static const int kDistinctFieldNumber = 5;
  inline bool distinct() const;
  inline void set_distinct(bool value);
  
  // optional string tablename = 6;
  inline bool has_tablename() const;
  inline void clear_tablename();
  static const int kTablenameFieldNumber = 6;
  inline const ::std::string& tablename() const;
  inline void set_tablename(const ::std::string& value);
  inline void set_tablename(const char* value);
  inline void set_tablename(const char* value, size_t size);
  inline ::std::string* mutable_tablename();
  
  // optional bool isNot = 7;
  inline bool has_isnot() const;
  inline void clear_isnot();
  static const int kIsNotFieldNumber = 7;
  inline bool isnot() const;
  inline void set_isnot(bool value);
  
  // @@protoc_insertion_point(class_scope:protobuf.Column)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* columnname_;
  static const ::std::string _default_columnname_;
  int valuetype_;
  int aggegatefunction_;
  ::std::string* alias_;
  static const ::std::string _default_alias_;
  bool distinct_;
  ::std::string* tablename_;
  static const ::std::string _default_tablename_;
  bool isnot_;
  friend void  protobuf_AddDesc_commands_2eproto();
  friend void protobuf_AssignDesc_commands_2eproto();
  friend void protobuf_ShutdownFile_commands_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Column* default_instance_;
};
// -------------------------------------------------------------------

class OrderBy : public ::google::protobuf::Message {
 public:
  OrderBy();
  virtual ~OrderBy();
  
  OrderBy(const OrderBy& from);
  
  inline OrderBy& operator=(const OrderBy& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderBy& default_instance();
  
  void Swap(OrderBy* other);
  
  // implements Message ----------------------------------------------
  
  OrderBy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderBy& from);
  void MergeFrom(const OrderBy& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef OrderBy_DIRECTION DIRECTION;
  static const DIRECTION ASC = OrderBy_DIRECTION_ASC;
  static const DIRECTION DESC = OrderBy_DIRECTION_DESC;
  static inline bool DIRECTION_IsValid(int value) {
    return OrderBy_DIRECTION_IsValid(value);
  }
  static const DIRECTION DIRECTION_MIN =
    OrderBy_DIRECTION_DIRECTION_MIN;
  static const DIRECTION DIRECTION_MAX =
    OrderBy_DIRECTION_DIRECTION_MAX;
  static const int DIRECTION_ARRAYSIZE =
    OrderBy_DIRECTION_DIRECTION_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DIRECTION_descriptor() {
    return OrderBy_DIRECTION_descriptor();
  }
  static inline const ::std::string& DIRECTION_Name(DIRECTION value) {
    return OrderBy_DIRECTION_Name(value);
  }
  static inline bool DIRECTION_Parse(const ::std::string& name,
      DIRECTION* value) {
    return OrderBy_DIRECTION_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .protobuf.OrderBy.DIRECTION direction = 1;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 1;
  inline ::protobuf::OrderBy_DIRECTION direction() const;
  inline void set_direction(::protobuf::OrderBy_DIRECTION value);
  
  // optional .protobuf.Expression column = 2;
  inline bool has_column() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 2;
  inline const ::protobuf::Expression& column() const;
  inline ::protobuf::Expression* mutable_column();
  
  // @@protoc_insertion_point(class_scope:protobuf.OrderBy)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int direction_;
  ::protobuf::Expression* column_;
  friend void  protobuf_AddDesc_commands_2eproto();
  friend void protobuf_AssignDesc_commands_2eproto();
  friend void protobuf_ShutdownFile_commands_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OrderBy* default_instance_;
};
// -------------------------------------------------------------------

class ResultSet : public ::google::protobuf::Message {
 public:
  ResultSet();
  virtual ~ResultSet();
  
  ResultSet(const ResultSet& from);
  
  inline ResultSet& operator=(const ResultSet& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResultSet& default_instance();
  
  void Swap(ResultSet* other);
  
  // implements Message ----------------------------------------------
  
  ResultSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResultSet& from);
  void MergeFrom(const ResultSet& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .protobuf.Expression keyColumns = 1;
  inline int keycolumns_size() const;
  inline void clear_keycolumns();
  static const int kKeyColumnsFieldNumber = 1;
  inline const ::protobuf::Expression& keycolumns(int index) const;
  inline ::protobuf::Expression* mutable_keycolumns(int index);
  inline ::protobuf::Expression* add_keycolumns();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >&
      keycolumns() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >*
      mutable_keycolumns();
  
  // repeated .protobuf.ValuesArray keyRows = 2;
  inline int keyrows_size() const;
  inline void clear_keyrows();
  static const int kKeyRowsFieldNumber = 2;
  inline const ::protobuf::ValuesArray& keyrows(int index) const;
  inline ::protobuf::ValuesArray* mutable_keyrows(int index);
  inline ::protobuf::ValuesArray* add_keyrows();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::ValuesArray >&
      keyrows() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::ValuesArray >*
      mutable_keyrows();
  
  // optional string exception = 3;
  inline bool has_exception() const;
  inline void clear_exception();
  static const int kExceptionFieldNumber = 3;
  inline const ::std::string& exception() const;
  inline void set_exception(const ::std::string& value);
  inline void set_exception(const char* value);
  inline void set_exception(const char* value, size_t size);
  inline ::std::string* mutable_exception();
  
  // optional int64 transactionId = 4;
  inline bool has_transactionid() const;
  inline void clear_transactionid();
  static const int kTransactionIdFieldNumber = 4;
  inline ::google::protobuf::int64 transactionid() const;
  inline void set_transactionid(::google::protobuf::int64 value);
  
  // optional int32 resultSetId = 5;
  inline bool has_resultsetid() const;
  inline void clear_resultsetid();
  static const int kResultSetIdFieldNumber = 5;
  inline ::google::protobuf::int32 resultsetid() const;
  inline void set_resultsetid(::google::protobuf::int32 value);
  
  // optional bool success = 6;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 6;
  inline bool success() const;
  inline void set_success(bool value);
  
  // repeated .protobuf.Expression valColumns = 7;
  inline int valcolumns_size() const;
  inline void clear_valcolumns();
  static const int kValColumnsFieldNumber = 7;
  inline const ::protobuf::Expression& valcolumns(int index) const;
  inline ::protobuf::Expression* mutable_valcolumns(int index);
  inline ::protobuf::Expression* add_valcolumns();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >&
      valcolumns() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >*
      mutable_valcolumns();
  
  // repeated .protobuf.ValuesArray valRows = 8;
  inline int valrows_size() const;
  inline void clear_valrows();
  static const int kValRowsFieldNumber = 8;
  inline const ::protobuf::ValuesArray& valrows(int index) const;
  inline ::protobuf::ValuesArray* mutable_valrows(int index);
  inline ::protobuf::ValuesArray* add_valrows();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::ValuesArray >&
      valrows() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::ValuesArray >*
      mutable_valrows();
  
  // optional .protobuf.ExtraMsg extraRouteMsg = 9;
  inline bool has_extraroutemsg() const;
  inline void clear_extraroutemsg();
  static const int kExtraRouteMsgFieldNumber = 9;
  inline const ::protobuf::ExtraMsg& extraroutemsg() const;
  inline ::protobuf::ExtraMsg* mutable_extraroutemsg();
  
  // repeated .protobuf.OrderBy orderBy = 10;
  inline int orderby_size() const;
  inline void clear_orderby();
  static const int kOrderByFieldNumber = 10;
  inline const ::protobuf::OrderBy& orderby(int index) const;
  inline ::protobuf::OrderBy* mutable_orderby(int index);
  inline ::protobuf::OrderBy* add_orderby();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::OrderBy >&
      orderby() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::OrderBy >*
      mutable_orderby();
  
  // repeated .protobuf.Expression selectionColumn = 11;
  inline int selectioncolumn_size() const;
  inline void clear_selectioncolumn();
  static const int kSelectionColumnFieldNumber = 11;
  inline const ::protobuf::Expression& selectioncolumn(int index) const;
  inline ::protobuf::Expression* mutable_selectioncolumn(int index);
  inline ::protobuf::Expression* add_selectioncolumn();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >&
      selectioncolumn() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >*
      mutable_selectioncolumn();
  
  // @@protoc_insertion_point(class_scope:protobuf.ResultSet)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::protobuf::Expression > keycolumns_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::ValuesArray > keyrows_;
  ::std::string* exception_;
  static const ::std::string _default_exception_;
  ::google::protobuf::int64 transactionid_;
  ::google::protobuf::int32 resultsetid_;
  bool success_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::Expression > valcolumns_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::ValuesArray > valrows_;
  ::protobuf::ExtraMsg* extraroutemsg_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::OrderBy > orderby_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::Expression > selectioncolumn_;
  friend void  protobuf_AddDesc_commands_2eproto();
  friend void protobuf_AssignDesc_commands_2eproto();
  friend void protobuf_ShutdownFile_commands_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ResultSet* default_instance_;
};
// -------------------------------------------------------------------

class ExtraMsg : public ::google::protobuf::Message {
 public:
  ExtraMsg();
  virtual ~ExtraMsg();
  
  ExtraMsg(const ExtraMsg& from);
  
  inline ExtraMsg& operator=(const ExtraMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtraMsg& default_instance();
  
  void Swap(ExtraMsg* other);
  
  // implements Message ----------------------------------------------
  
  ExtraMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExtraMsg& from);
  void MergeFrom(const ExtraMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string extraRouteKey = 1;
  inline int extraroutekey_size() const;
  inline void clear_extraroutekey();
  static const int kExtraRouteKeyFieldNumber = 1;
  inline const ::std::string& extraroutekey(int index) const;
  inline ::std::string* mutable_extraroutekey(int index);
  inline void set_extraroutekey(int index, const ::std::string& value);
  inline void set_extraroutekey(int index, const char* value);
  inline void set_extraroutekey(int index, const char* value, size_t size);
  inline ::std::string* add_extraroutekey();
  inline void add_extraroutekey(const ::std::string& value);
  inline void add_extraroutekey(const char* value);
  inline void add_extraroutekey(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& extraroutekey() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_extraroutekey();
  
  // optional .protobuf.ValuesArray extraRouteValue = 2;
  inline bool has_extraroutevalue() const;
  inline void clear_extraroutevalue();
  static const int kExtraRouteValueFieldNumber = 2;
  inline const ::protobuf::ValuesArray& extraroutevalue() const;
  inline ::protobuf::ValuesArray* mutable_extraroutevalue();
  
  // @@protoc_insertion_point(class_scope:protobuf.ExtraMsg)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> extraroutekey_;
  ::protobuf::ValuesArray* extraroutevalue_;
  friend void  protobuf_AddDesc_commands_2eproto();
  friend void protobuf_AssignDesc_commands_2eproto();
  friend void protobuf_ShutdownFile_commands_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ExtraMsg* default_instance_;
};
// -------------------------------------------------------------------

class QueryCommon : public ::google::protobuf::Message {
 public:
  QueryCommon();
  virtual ~QueryCommon();
  
  QueryCommon(const QueryCommon& from);
  
  inline QueryCommon& operator=(const QueryCommon& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryCommon& default_instance();
  
  void Swap(QueryCommon* other);
  
  // implements Message ----------------------------------------------
  
  QueryCommon* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryCommon& from);
  void MergeFrom(const QueryCommon& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef QueryCommon_QUERY_CONCURRENCY QUERY_CONCURRENCY;
  static const QUERY_CONCURRENCY SEQUENTIAL = QueryCommon_QUERY_CONCURRENCY_SEQUENTIAL;
  static const QUERY_CONCURRENCY CONCURRENT = QueryCommon_QUERY_CONCURRENCY_CONCURRENT;
  static inline bool QUERY_CONCURRENCY_IsValid(int value) {
    return QueryCommon_QUERY_CONCURRENCY_IsValid(value);
  }
  static const QUERY_CONCURRENCY QUERY_CONCURRENCY_MIN =
    QueryCommon_QUERY_CONCURRENCY_QUERY_CONCURRENCY_MIN;
  static const QUERY_CONCURRENCY QUERY_CONCURRENCY_MAX =
    QueryCommon_QUERY_CONCURRENCY_QUERY_CONCURRENCY_MAX;
  static const int QUERY_CONCURRENCY_ARRAYSIZE =
    QueryCommon_QUERY_CONCURRENCY_QUERY_CONCURRENCY_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  QUERY_CONCURRENCY_descriptor() {
    return QueryCommon_QUERY_CONCURRENCY_descriptor();
  }
  static inline const ::std::string& QUERY_CONCURRENCY_Name(QUERY_CONCURRENCY value) {
    return QueryCommon_QUERY_CONCURRENCY_Name(value);
  }
  static inline bool QUERY_CONCURRENCY_Parse(const ::std::string& name,
      QUERY_CONCURRENCY* value) {
    return QueryCommon_QUERY_CONCURRENCY_Parse(name, value);
  }
  
  typedef QueryCommon_PlanType PlanType;
  static const PlanType NEST_LOOP_JOIN = QueryCommon_PlanType_NEST_LOOP_JOIN;
  static const PlanType SORT_MERGE_JOIN = QueryCommon_PlanType_SORT_MERGE_JOIN;
  static const PlanType HASH_JOIN = QueryCommon_PlanType_HASH_JOIN;
  static const PlanType QUERY = QueryCommon_PlanType_QUERY;
  static const PlanType INDEX_NEST_LOOP = QueryCommon_PlanType_INDEX_NEST_LOOP;
  static const PlanType MERGE = QueryCommon_PlanType_MERGE;
  static inline bool PlanType_IsValid(int value) {
    return QueryCommon_PlanType_IsValid(value);
  }
  static const PlanType PlanType_MIN =
    QueryCommon_PlanType_PlanType_MIN;
  static const PlanType PlanType_MAX =
    QueryCommon_PlanType_PlanType_MAX;
  static const int PlanType_ARRAYSIZE =
    QueryCommon_PlanType_PlanType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PlanType_descriptor() {
    return QueryCommon_PlanType_descriptor();
  }
  static inline const ::std::string& PlanType_Name(PlanType value) {
    return QueryCommon_PlanType_Name(value);
  }
  static inline bool PlanType_Parse(const ::std::string& name,
      PlanType* value) {
    return QueryCommon_PlanType_Parse(name, value);
  }
  
  typedef QueryCommon_LockModel LockModel;
  static const LockModel SHARED_LOCK = QueryCommon_LockModel_SHARED_LOCK;
  static const LockModel EXCLUSIVE_LOCK = QueryCommon_LockModel_EXCLUSIVE_LOCK;
  static inline bool LockModel_IsValid(int value) {
    return QueryCommon_LockModel_IsValid(value);
  }
  static const LockModel LockModel_MIN =
    QueryCommon_LockModel_LockModel_MIN;
  static const LockModel LockModel_MAX =
    QueryCommon_LockModel_LockModel_MAX;
  static const int LockModel_ARRAYSIZE =
    QueryCommon_LockModel_LockModel_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LockModel_descriptor() {
    return QueryCommon_LockModel_descriptor();
  }
  static inline const ::std::string& LockModel_Name(LockModel value) {
    return QueryCommon_LockModel_Name(value);
  }
  static inline bool LockModel_Parse(const ::std::string& name,
      LockModel* value) {
    return QueryCommon_LockModel_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // repeated .protobuf.OrderBy orderBy = 1;
  inline int orderby_size() const;
  inline void clear_orderby();
  static const int kOrderByFieldNumber = 1;
  inline const ::protobuf::OrderBy& orderby(int index) const;
  inline ::protobuf::OrderBy* mutable_orderby(int index);
  inline ::protobuf::OrderBy* add_orderby();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::OrderBy >&
      orderby() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::OrderBy >*
      mutable_orderby();
  
  // optional int64 limitFrom = 2;
  inline bool has_limitfrom() const;
  inline void clear_limitfrom();
  static const int kLimitFromFieldNumber = 2;
  inline ::google::protobuf::int64 limitfrom() const;
  inline void set_limitfrom(::google::protobuf::int64 value);
  
  // optional int64 limitTo = 3;
  inline bool has_limitto() const;
  inline void clear_limitto();
  static const int kLimitToFieldNumber = 3;
  inline ::google::protobuf::int64 limitto() const;
  inline void set_limitto(::google::protobuf::int64 value);
  
  // optional .protobuf.Filter valueFilters = 4;
  inline bool has_valuefilters() const;
  inline void clear_valuefilters();
  static const int kValueFiltersFieldNumber = 4;
  inline const ::protobuf::Filter& valuefilters() const;
  inline ::protobuf::Filter* mutable_valuefilters();
  
  // repeated .protobuf.Expression selectionColumn = 5;
  inline int selectioncolumn_size() const;
  inline void clear_selectioncolumn();
  static const int kSelectionColumnFieldNumber = 5;
  inline const ::protobuf::Expression& selectioncolumn(int index) const;
  inline ::protobuf::Expression* mutable_selectioncolumn(int index);
  inline ::protobuf::Expression* add_selectioncolumn();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >&
      selectioncolumn() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >*
      mutable_selectioncolumn();
  
  // repeated .protobuf.OrderBy groupBy = 6;
  inline int groupby_size() const;
  inline void clear_groupby();
  static const int kGroupByFieldNumber = 6;
  inline const ::protobuf::OrderBy& groupby(int index) const;
  inline ::protobuf::OrderBy* mutable_groupby(int index);
  inline ::protobuf::OrderBy* add_groupby();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::OrderBy >&
      groupby() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::OrderBy >*
      mutable_groupby();
  
  // optional .protobuf.Filter keyFilter = 7;
  inline bool has_keyfilter() const;
  inline void clear_keyfilter();
  static const int kKeyFilterFieldNumber = 7;
  inline const ::protobuf::Filter& keyfilter() const;
  inline ::protobuf::Filter* mutable_keyfilter();
  
  // optional string idxName = 8;
  inline bool has_idxname() const;
  inline void clear_idxname();
  static const int kIdxNameFieldNumber = 8;
  inline const ::std::string& idxname() const;
  inline void set_idxname(const ::std::string& value);
  inline void set_idxname(const char* value);
  inline void set_idxname(const char* value, size_t size);
  inline ::std::string* mutable_idxname();
  
  // optional .protobuf.QueryCommon.PlanType planNodeType = 9;
  inline bool has_plannodetype() const;
  inline void clear_plannodetype();
  static const int kPlanNodeTypeFieldNumber = 9;
  inline ::protobuf::QueryCommon_PlanType plannodetype() const;
  inline void set_plannodetype(::protobuf::QueryCommon_PlanType value);
  
  // repeated .protobuf.CommandNode subNodes = 10;
  inline int subnodes_size() const;
  inline void clear_subnodes();
  static const int kSubNodesFieldNumber = 10;
  inline const ::protobuf::CommandNode& subnodes(int index) const;
  inline ::protobuf::CommandNode* mutable_subnodes(int index);
  inline ::protobuf::CommandNode* add_subnodes();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::CommandNode >&
      subnodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::CommandNode >*
      mutable_subnodes();
  
  // optional string dataNodeKey = 12;
  inline bool has_datanodekey() const;
  inline void clear_datanodekey();
  static const int kDataNodeKeyFieldNumber = 12;
  inline const ::std::string& datanodekey() const;
  inline void set_datanodekey(const ::std::string& value);
  inline void set_datanodekey(const char* value);
  inline void set_datanodekey(const char* value, size_t size);
  inline ::std::string* mutable_datanodekey();
  
  // optional .protobuf.QueryCommon.LockModel lockModel = 13;
  inline bool has_lockmodel() const;
  inline void clear_lockmodel();
  static const int kLockModelFieldNumber = 13;
  inline ::protobuf::QueryCommon_LockModel lockmodel() const;
  inline void set_lockmodel(::protobuf::QueryCommon_LockModel value);
  
  // optional bool consistentRead = 14;
  inline bool has_consistentread() const;
  inline void clear_consistentread();
  static const int kConsistentReadFieldNumber = 14;
  inline bool consistentread() const;
  inline void set_consistentread(bool value);
  
  // optional .protobuf.QueryCommon.QUERY_CONCURRENCY queryConcurrency = 15;
  inline bool has_queryconcurrency() const;
  inline void clear_queryconcurrency();
  static const int kQueryConcurrencyFieldNumber = 15;
  inline ::protobuf::QueryCommon_QUERY_CONCURRENCY queryconcurrency() const;
  inline void set_queryconcurrency(::protobuf::QueryCommon_QUERY_CONCURRENCY value);
  
  // optional bool leftOuter = 16;
  inline bool has_leftouter() const;
  inline void clear_leftouter();
  static const int kLeftOuterFieldNumber = 16;
  inline bool leftouter() const;
  inline void set_leftouter(bool value);
  
  // optional bool rightOuter = 17;
  inline bool has_rightouter() const;
  inline void clear_rightouter();
  static const int kRightOuterFieldNumber = 17;
  inline bool rightouter() const;
  inline void set_rightouter(bool value);
  
  // repeated .protobuf.Column rightJoinOnColumn = 18;
  inline int rightjoinoncolumn_size() const;
  inline void clear_rightjoinoncolumn();
  static const int kRightJoinOnColumnFieldNumber = 18;
  inline const ::protobuf::Column& rightjoinoncolumn(int index) const;
  inline ::protobuf::Column* mutable_rightjoinoncolumn(int index);
  inline ::protobuf::Column* add_rightjoinoncolumn();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::Column >&
      rightjoinoncolumn() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::Column >*
      mutable_rightjoinoncolumn();
  
  // repeated .protobuf.Column leftJoinOnColumn = 19;
  inline int leftjoinoncolumn_size() const;
  inline void clear_leftjoinoncolumn();
  static const int kLeftJoinOnColumnFieldNumber = 19;
  inline const ::protobuf::Column& leftjoinoncolumn(int index) const;
  inline ::protobuf::Column* mutable_leftjoinoncolumn(int index);
  inline ::protobuf::Column* add_leftjoinoncolumn();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::Column >&
      leftjoinoncolumn() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::Column >*
      mutable_leftjoinoncolumn();
  
  // optional string alias = 20;
  inline bool has_alias() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 20;
  inline const ::std::string& alias() const;
  inline void set_alias(const ::std::string& value);
  inline void set_alias(const char* value);
  inline void set_alias(const char* value, size_t size);
  inline ::std::string* mutable_alias();
  
  // optional int64 requestID = 21;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 21;
  inline ::google::protobuf::int64 requestid() const;
  inline void set_requestid(::google::protobuf::int64 value);
  
  // optional string requestHostName = 22;
  inline bool has_requesthostname() const;
  inline void clear_requesthostname();
  static const int kRequestHostNameFieldNumber = 22;
  inline const ::std::string& requesthostname() const;
  inline void set_requesthostname(const ::std::string& value);
  inline void set_requesthostname(const char* value);
  inline void set_requesthostname(const char* value, size_t size);
  inline ::std::string* mutable_requesthostname();
  
  // optional int32 subRequestID = 23;
  inline bool has_subrequestid() const;
  inline void clear_subrequestid();
  static const int kSubRequestIDFieldNumber = 23;
  inline ::google::protobuf::int32 subrequestid() const;
  inline void set_subrequestid(::google::protobuf::int32 value);
  
  // optional int32 thread = 24;
  inline bool has_thread() const;
  inline void clear_thread();
  static const int kThreadFieldNumber = 24;
  inline ::google::protobuf::int32 thread() const;
  inline void set_thread(::google::protobuf::int32 value);
  
  // optional bool sharded = 25;
  inline bool has_sharded() const;
  inline void clear_sharded();
  static const int kShardedFieldNumber = 25;
  inline bool sharded() const;
  inline void set_sharded(bool value);
  
  // optional bool canMerge = 26;
  inline bool has_canmerge() const;
  inline void clear_canmerge();
  static const int kCanMergeFieldNumber = 26;
  inline bool canmerge() const;
  inline void set_canmerge(bool value);
  
  // optional bool useTempTableExplicit = 27;
  inline bool has_usetemptableexplicit() const;
  inline void clear_usetemptableexplicit();
  static const int kUseTempTableExplicitFieldNumber = 27;
  inline bool usetemptableexplicit() const;
  inline void set_usetemptableexplicit(bool value);
  
  // optional string actualTable = 28;
  inline bool has_actualtable() const;
  inline void clear_actualtable();
  static const int kActualTableFieldNumber = 28;
  inline const ::std::string& actualtable() const;
  inline void set_actualtable(const ::std::string& value);
  inline void set_actualtable(const char* value);
  inline void set_actualtable(const char* value, size_t size);
  inline ::std::string* mutable_actualtable();
  
  // optional bool isSubQuery = 29;
  inline bool has_issubquery() const;
  inline void clear_issubquery();
  static const int kIsSubQueryFieldNumber = 29;
  inline bool issubquery() const;
  inline void set_issubquery(bool value);
  
  // optional bool isUnion = 30;
  inline bool has_isunion() const;
  inline void clear_isunion();
  static const int kIsUnionFieldNumber = 30;
  inline bool isunion() const;
  inline void set_isunion(bool value);
  
  // optional .protobuf.Filter otherJoinFilter = 31;
  inline bool has_otherjoinfilter() const;
  inline void clear_otherjoinfilter();
  static const int kOtherJoinFilterFieldNumber = 31;
  inline const ::protobuf::Filter& otherjoinfilter() const;
  inline ::protobuf::Filter* mutable_otherjoinfilter();
  
  // @@protoc_insertion_point(class_scope:protobuf.QueryCommon)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::protobuf::OrderBy > orderby_;
  ::google::protobuf::int64 limitfrom_;
  ::google::protobuf::int64 limitto_;
  ::protobuf::Filter* valuefilters_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::Expression > selectioncolumn_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::OrderBy > groupby_;
  ::protobuf::Filter* keyfilter_;
  ::std::string* idxname_;
  static const ::std::string _default_idxname_;
  int plannodetype_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::CommandNode > subnodes_;
  ::std::string* datanodekey_;
  static const ::std::string _default_datanodekey_;
  int lockmodel_;
  bool consistentread_;
  int queryconcurrency_;
  bool leftouter_;
  bool rightouter_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::Column > rightjoinoncolumn_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::Column > leftjoinoncolumn_;
  ::std::string* alias_;
  static const ::std::string _default_alias_;
  ::google::protobuf::int64 requestid_;
  ::std::string* requesthostname_;
  static const ::std::string _default_requesthostname_;
  ::google::protobuf::int32 subrequestid_;
  ::google::protobuf::int32 thread_;
  bool sharded_;
  bool canmerge_;
  bool usetemptableexplicit_;
  ::std::string* actualtable_;
  static const ::std::string _default_actualtable_;
  bool issubquery_;
  bool isunion_;
  ::protobuf::Filter* otherjoinfilter_;
  friend void  protobuf_AddDesc_commands_2eproto();
  friend void protobuf_AssignDesc_commands_2eproto();
  friend void protobuf_ShutdownFile_commands_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(30 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static QueryCommon* default_instance_;
};
// -------------------------------------------------------------------

class Put : public ::google::protobuf::Message {
 public:
  Put();
  virtual ~Put();
  
  Put(const Put& from);
  
  inline Put& operator=(const Put& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Put& default_instance();
  
  void Swap(Put* other);
  
  // implements Message ----------------------------------------------
  
  Put* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Put& from);
  void MergeFrom(const Put& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Put_PUT_TYPE PUT_TYPE;
  static const PUT_TYPE REPLACE = Put_PUT_TYPE_REPLACE;
  static const PUT_TYPE INSERT = Put_PUT_TYPE_INSERT;
  static const PUT_TYPE DELETE = Put_PUT_TYPE_DELETE;
  static const PUT_TYPE UPDATE = Put_PUT_TYPE_UPDATE;
  static inline bool PUT_TYPE_IsValid(int value) {
    return Put_PUT_TYPE_IsValid(value);
  }
  static const PUT_TYPE PUT_TYPE_MIN =
    Put_PUT_TYPE_PUT_TYPE_MIN;
  static const PUT_TYPE PUT_TYPE_MAX =
    Put_PUT_TYPE_PUT_TYPE_MAX;
  static const int PUT_TYPE_ARRAYSIZE =
    Put_PUT_TYPE_PUT_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PUT_TYPE_descriptor() {
    return Put_PUT_TYPE_descriptor();
  }
  static inline const ::std::string& PUT_TYPE_Name(PUT_TYPE value) {
    return Put_PUT_TYPE_Name(value);
  }
  static inline bool PUT_TYPE_Parse(const ::std::string& name,
      PUT_TYPE* value) {
    return Put_PUT_TYPE_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .protobuf.QueryCommon queryCommon = 1;
  inline bool has_querycommon() const;
  inline void clear_querycommon();
  static const int kQueryCommonFieldNumber = 1;
  inline const ::protobuf::QueryCommon& querycommon() const;
  inline ::protobuf::QueryCommon* mutable_querycommon();
  
  // repeated .protobuf.Expression columns = 2;
  inline int columns_size() const;
  inline void clear_columns();
  static const int kColumnsFieldNumber = 2;
  inline const ::protobuf::Expression& columns(int index) const;
  inline ::protobuf::Expression* mutable_columns(int index);
  inline ::protobuf::Expression* add_columns();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >&
      columns() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >*
      mutable_columns();
  
  // optional string indexName = 3;
  inline bool has_indexname() const;
  inline void clear_indexname();
  static const int kIndexNameFieldNumber = 3;
  inline const ::std::string& indexname() const;
  inline void set_indexname(const ::std::string& value);
  inline void set_indexname(const char* value);
  inline void set_indexname(const char* value, size_t size);
  inline ::std::string* mutable_indexname();
  
  // optional .protobuf.Put.PUT_TYPE putType = 4;
  inline bool has_puttype() const;
  inline void clear_puttype();
  static const int kPutTypeFieldNumber = 4;
  inline ::protobuf::Put_PUT_TYPE puttype() const;
  inline void set_puttype(::protobuf::Put_PUT_TYPE value);
  
  // repeated .protobuf.Expression updateVal = 5;
  inline int updateval_size() const;
  inline void clear_updateval();
  static const int kUpdateValFieldNumber = 5;
  inline const ::protobuf::Expression& updateval(int index) const;
  inline ::protobuf::Expression* mutable_updateval(int index);
  inline ::protobuf::Expression* add_updateval();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >&
      updateval() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >*
      mutable_updateval();
  
  // optional string dataNodeKey = 6;
  inline bool has_datanodekey() const;
  inline void clear_datanodekey();
  static const int kDataNodeKeyFieldNumber = 6;
  inline const ::std::string& datanodekey() const;
  inline void set_datanodekey(const ::std::string& value);
  inline void set_datanodekey(const char* value);
  inline void set_datanodekey(const char* value, size_t size);
  inline ::std::string* mutable_datanodekey();
  
  // optional int32 thread = 7;
  inline bool has_thread() const;
  inline void clear_thread();
  static const int kThreadFieldNumber = 7;
  inline ::google::protobuf::int32 thread() const;
  inline void set_thread(::google::protobuf::int32 value);
  
  // optional string indexKey = 8;
  inline bool has_indexkey() const;
  inline void clear_indexkey();
  static const int kIndexKeyFieldNumber = 8;
  inline const ::std::string& indexkey() const;
  inline void set_indexkey(const ::std::string& value);
  inline void set_indexkey(const char* value);
  inline void set_indexkey(const char* value, size_t size);
  inline ::std::string* mutable_indexkey();
  
  // @@protoc_insertion_point(class_scope:protobuf.Put)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::protobuf::QueryCommon* querycommon_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::Expression > columns_;
  ::std::string* indexname_;
  static const ::std::string _default_indexname_;
  int puttype_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::Expression > updateval_;
  ::std::string* datanodekey_;
  static const ::std::string _default_datanodekey_;
  ::google::protobuf::int32 thread_;
  ::std::string* indexkey_;
  static const ::std::string _default_indexkey_;
  friend void  protobuf_AddDesc_commands_2eproto();
  friend void protobuf_AssignDesc_commands_2eproto();
  friend void protobuf_ShutdownFile_commands_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Put* default_instance_;
};
// -------------------------------------------------------------------

class Filter : public ::google::protobuf::Message {
 public:
  Filter();
  virtual ~Filter();
  
  Filter(const Filter& from);
  
  inline Filter& operator=(const Filter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Filter& default_instance();
  
  void Swap(Filter* other);
  
  // implements Message ----------------------------------------------
  
  Filter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Filter& from);
  void MergeFrom(const Filter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Filter_AccessType AccessType;
  static const AccessType AND = Filter_AccessType_AND;
  static const AccessType OR = Filter_AccessType_OR;
  static const AccessType GT = Filter_AccessType_GT;
  static const AccessType LT = Filter_AccessType_LT;
  static const AccessType GT_EQ = Filter_AccessType_GT_EQ;
  static const AccessType LT_EQ = Filter_AccessType_LT_EQ;
  static const AccessType EQ = Filter_AccessType_EQ;
  static const AccessType LIKE = Filter_AccessType_LIKE;
  static const AccessType IS_NULL = Filter_AccessType_IS_NULL;
  static const AccessType IS_NOT_NULL = Filter_AccessType_IS_NOT_NULL;
  static const AccessType NOT_EQ = Filter_AccessType_NOT_EQ;
  static const AccessType IN = Filter_AccessType_IN;
  static const AccessType IS = Filter_AccessType_IS;
  static const AccessType CONSTANT = Filter_AccessType_CONSTANT;
  static const AccessType NULL_SAFE_EQUAL = Filter_AccessType_NULL_SAFE_EQUAL;
  static inline bool AccessType_IsValid(int value) {
    return Filter_AccessType_IsValid(value);
  }
  static const AccessType AccessType_MIN =
    Filter_AccessType_AccessType_MIN;
  static const AccessType AccessType_MAX =
    Filter_AccessType_AccessType_MAX;
  static const int AccessType_ARRAYSIZE =
    Filter_AccessType_AccessType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AccessType_descriptor() {
    return Filter_AccessType_descriptor();
  }
  static inline const ::std::string& AccessType_Name(AccessType value) {
    return Filter_AccessType_Name(value);
  }
  static inline bool AccessType_Parse(const ::std::string& name,
      AccessType* value) {
    return Filter_AccessType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .protobuf.Expression column = 1;
  inline bool has_column() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 1;
  inline const ::protobuf::Expression& column() const;
  inline ::protobuf::Expression* mutable_column();
  
  // optional .protobuf.Filter.AccessType accessType = 2;
  inline bool has_accesstype() const;
  inline void clear_accesstype();
  static const int kAccessTypeFieldNumber = 2;
  inline ::protobuf::Filter_AccessType accesstype() const;
  inline void set_accesstype(::protobuf::Filter_AccessType value);
  
  // optional .protobuf.Expression value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::protobuf::Expression& value() const;
  inline ::protobuf::Expression* mutable_value();
  
  // repeated .protobuf.Expression subChildren = 4;
  inline int subchildren_size() const;
  inline void clear_subchildren();
  static const int kSubChildrenFieldNumber = 4;
  inline const ::protobuf::Expression& subchildren(int index) const;
  inline ::protobuf::Expression* mutable_subchildren(int index);
  inline ::protobuf::Expression* add_subchildren();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >&
      subchildren() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >*
      mutable_subchildren();
  
  // repeated .protobuf.Expression values = 5;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 5;
  inline const ::protobuf::Expression& values(int index) const;
  inline ::protobuf::Expression* mutable_values(int index);
  inline ::protobuf::Expression* add_values();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >&
      values() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >*
      mutable_values();
  
  // optional bool inFromUser = 6;
  inline bool has_infromuser() const;
  inline void clear_infromuser();
  static const int kInFromUserFieldNumber = 6;
  inline bool infromuser() const;
  inline void set_infromuser(bool value);
  
  // optional bool isNot = 7;
  inline bool has_isnot() const;
  inline void clear_isnot();
  static const int kIsNotFieldNumber = 7;
  inline bool isnot() const;
  inline void set_isnot(bool value);
  
  // @@protoc_insertion_point(class_scope:protobuf.Filter)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::protobuf::Expression* column_;
  int accesstype_;
  ::protobuf::Expression* value_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::Expression > subchildren_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::Expression > values_;
  bool infromuser_;
  bool isnot_;
  friend void  protobuf_AddDesc_commands_2eproto();
  friend void protobuf_AssignDesc_commands_2eproto();
  friend void protobuf_ShutdownFile_commands_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Filter* default_instance_;
};
// -------------------------------------------------------------------

class CommandNode : public ::google::protobuf::Message {
 public:
  CommandNode();
  virtual ~CommandNode();
  
  CommandNode(const CommandNode& from);
  
  inline CommandNode& operator=(const CommandNode& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandNode& default_instance();
  
  void Swap(CommandNode* other);
  
  // implements Message ----------------------------------------------
  
  CommandNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandNode& from);
  void MergeFrom(const CommandNode& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .protobuf.Put put = 1;
  inline bool has_put() const;
  inline void clear_put();
  static const int kPutFieldNumber = 1;
  inline const ::protobuf::Put& put() const;
  inline ::protobuf::Put* mutable_put();
  
  // optional .protobuf.QueryCommon queryCommon = 2;
  inline bool has_querycommon() const;
  inline void clear_querycommon();
  static const int kQueryCommonFieldNumber = 2;
  inline const ::protobuf::QueryCommon& querycommon() const;
  inline ::protobuf::QueryCommon* mutable_querycommon();
  
  // @@protoc_insertion_point(class_scope:protobuf.CommandNode)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::protobuf::Put* put_;
  ::protobuf::QueryCommon* querycommon_;
  friend void  protobuf_AddDesc_commands_2eproto();
  friend void protobuf_AssignDesc_commands_2eproto();
  friend void protobuf_ShutdownFile_commands_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CommandNode* default_instance_;
};
// -------------------------------------------------------------------

class CommandRequest : public ::google::protobuf::Message {
 public:
  CommandRequest();
  virtual ~CommandRequest();
  
  CommandRequest(const CommandRequest& from);
  
  inline CommandRequest& operator=(const CommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandRequest& default_instance();
  
  void Swap(CommandRequest* other);
  
  // implements Message ----------------------------------------------
  
  CommandRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandRequest& from);
  void MergeFrom(const CommandRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool createNewTransaction = 1;
  inline bool has_createnewtransaction() const;
  inline void clear_createnewtransaction();
  static const int kCreateNewTransactionFieldNumber = 1;
  inline bool createnewtransaction() const;
  inline void set_createnewtransaction(bool value);
  
  // optional int64 transactionSequence = 2;
  inline bool has_transactionsequence() const;
  inline void clear_transactionsequence();
  static const int kTransactionSequenceFieldNumber = 2;
  inline ::google::protobuf::int64 transactionsequence() const;
  inline void set_transactionsequence(::google::protobuf::int64 value);
  
  // optional .protobuf.CommandNode cmdNode = 3;
  inline bool has_cmdnode() const;
  inline void clear_cmdnode();
  static const int kCmdNodeFieldNumber = 3;
  inline const ::protobuf::CommandNode& cmdnode() const;
  inline ::protobuf::CommandNode* mutable_cmdnode();
  
  // optional .protobuf.ExtraMsg extramsg = 4;
  inline bool has_extramsg() const;
  inline void clear_extramsg();
  static const int kExtramsgFieldNumber = 4;
  inline const ::protobuf::ExtraMsg& extramsg() const;
  inline ::protobuf::ExtraMsg* mutable_extramsg();
  
  // optional int32 fetchSize = 5;
  inline bool has_fetchsize() const;
  inline void clear_fetchsize();
  static const int kFetchSizeFieldNumber = 5;
  inline ::google::protobuf::int32 fetchsize() const;
  inline void set_fetchsize(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:protobuf.CommandRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  bool createnewtransaction_;
  ::google::protobuf::int64 transactionsequence_;
  ::protobuf::CommandNode* cmdnode_;
  ::protobuf::ExtraMsg* extramsg_;
  ::google::protobuf::int32 fetchsize_;
  friend void  protobuf_AddDesc_commands_2eproto();
  friend void protobuf_AssignDesc_commands_2eproto();
  friend void protobuf_ShutdownFile_commands_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CommandRequest* default_instance_;
};
// -------------------------------------------------------------------

class ResultSetRequest : public ::google::protobuf::Message {
 public:
  ResultSetRequest();
  virtual ~ResultSetRequest();
  
  ResultSetRequest(const ResultSetRequest& from);
  
  inline ResultSetRequest& operator=(const ResultSetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResultSetRequest& default_instance();
  
  void Swap(ResultSetRequest* other);
  
  // implements Message ----------------------------------------------
  
  ResultSetRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResultSetRequest& from);
  void MergeFrom(const ResultSetRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 resultSequence = 1;
  inline bool has_resultsequence() const;
  inline void clear_resultsequence();
  static const int kResultSequenceFieldNumber = 1;
  inline ::google::protobuf::int32 resultsequence() const;
  inline void set_resultsequence(::google::protobuf::int32 value);
  
  // optional int32 fetchSize = 2;
  inline bool has_fetchsize() const;
  inline void clear_fetchsize();
  static const int kFetchSizeFieldNumber = 2;
  inline ::google::protobuf::int32 fetchsize() const;
  inline void set_fetchsize(::google::protobuf::int32 value);
  
  // optional .protobuf.ExtraMsg extramsg = 3;
  inline bool has_extramsg() const;
  inline void clear_extramsg();
  static const int kExtramsgFieldNumber = 3;
  inline const ::protobuf::ExtraMsg& extramsg() const;
  inline ::protobuf::ExtraMsg* mutable_extramsg();
  
  // @@protoc_insertion_point(class_scope:protobuf.ResultSetRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 resultsequence_;
  ::google::protobuf::int32 fetchsize_;
  ::protobuf::ExtraMsg* extramsg_;
  friend void  protobuf_AddDesc_commands_2eproto();
  friend void protobuf_AssignDesc_commands_2eproto();
  friend void protobuf_ShutdownFile_commands_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ResultSetRequest* default_instance_;
};
// -------------------------------------------------------------------

class TransactionRequest : public ::google::protobuf::Message {
 public:
  TransactionRequest();
  virtual ~TransactionRequest();
  
  TransactionRequest(const TransactionRequest& from);
  
  inline TransactionRequest& operator=(const TransactionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionRequest& default_instance();
  
  void Swap(TransactionRequest* other);
  
  // implements Message ----------------------------------------------
  
  TransactionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransactionRequest& from);
  void MergeFrom(const TransactionRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int64 transactionSequence = 1;
  inline bool has_transactionsequence() const;
  inline void clear_transactionsequence();
  static const int kTransactionSequenceFieldNumber = 1;
  inline ::google::protobuf::int64 transactionsequence() const;
  inline void set_transactionsequence(::google::protobuf::int64 value);
  
  // optional .protobuf.ExtraMsg extramsg = 2;
  inline bool has_extramsg() const;
  inline void clear_extramsg();
  static const int kExtramsgFieldNumber = 2;
  inline const ::protobuf::ExtraMsg& extramsg() const;
  inline ::protobuf::ExtraMsg* mutable_extramsg();
  
  // @@protoc_insertion_point(class_scope:protobuf.TransactionRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int64 transactionsequence_;
  ::protobuf::ExtraMsg* extramsg_;
  friend void  protobuf_AddDesc_commands_2eproto();
  friend void protobuf_AssignDesc_commands_2eproto();
  friend void protobuf_ShutdownFile_commands_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TransactionRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginRequest : public ::google::protobuf::Message {
 public:
  LoginRequest();
  virtual ~LoginRequest();
  
  LoginRequest(const LoginRequest& from);
  
  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();
  
  void Swap(LoginRequest* other);
  
  // implements Message ----------------------------------------------
  
  LoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  
  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  
  // optional .protobuf.ExtraMsg extramsg = 3;
  inline bool has_extramsg() const;
  inline void clear_extramsg();
  static const int kExtramsgFieldNumber = 3;
  inline const ::protobuf::ExtraMsg& extramsg() const;
  inline ::protobuf::ExtraMsg* mutable_extramsg();
  
  // @@protoc_insertion_point(class_scope:protobuf.LoginRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* user_;
  static const ::std::string _default_user_;
  ::std::string* password_;
  static const ::std::string _default_password_;
  ::protobuf::ExtraMsg* extramsg_;
  friend void  protobuf_AddDesc_commands_2eproto();
  friend void protobuf_AssignDesc_commands_2eproto();
  friend void protobuf_ShutdownFile_commands_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class PingRequest : public ::google::protobuf::Message {
 public:
  PingRequest();
  virtual ~PingRequest();
  
  PingRequest(const PingRequest& from);
  
  inline PingRequest& operator=(const PingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PingRequest& default_instance();
  
  void Swap(PingRequest* other);
  
  // implements Message ----------------------------------------------
  
  PingRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PingRequest& from);
  void MergeFrom(const PingRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string msg = 1;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 1;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  
  // optional .protobuf.ExtraMsg extramsg = 2;
  inline bool has_extramsg() const;
  inline void clear_extramsg();
  static const int kExtramsgFieldNumber = 2;
  inline const ::protobuf::ExtraMsg& extramsg() const;
  inline ::protobuf::ExtraMsg* mutable_extramsg();
  
  // @@protoc_insertion_point(class_scope:protobuf.PingRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* msg_;
  static const ::std::string _default_msg_;
  ::protobuf::ExtraMsg* extramsg_;
  friend void  protobuf_AddDesc_commands_2eproto();
  friend void protobuf_AssignDesc_commands_2eproto();
  friend void protobuf_ShutdownFile_commands_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static PingRequest* default_instance_;
};
// ===================================================================

class CommandExecutor_Stub;

class CommandExecutor : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline CommandExecutor() {};
 public:
  virtual ~CommandExecutor();
  
  typedef CommandExecutor_Stub Stub;
  
  static const ::google::protobuf::ServiceDescriptor* descriptor();
  
  virtual void ping(::google::protobuf::RpcController* controller,
                       const ::protobuf::PingRequest* request,
                       ::protobuf::ResultSet* response,
                       ::google::protobuf::Closure* done);
  virtual void login(::google::protobuf::RpcController* controller,
                       const ::protobuf::LoginRequest* request,
                       ::protobuf::ResultSet* response,
                       ::google::protobuf::Closure* done);
  virtual void execute(::google::protobuf::RpcController* controller,
                       const ::protobuf::CommandRequest* request,
                       ::protobuf::ResultSet* response,
                       ::google::protobuf::Closure* done);
  virtual void fetchNext(::google::protobuf::RpcController* controller,
                       const ::protobuf::ResultSetRequest* request,
                       ::protobuf::ResultSet* response,
                       ::google::protobuf::Closure* done);
  virtual void closeResultSet(::google::protobuf::RpcController* controller,
                       const ::protobuf::ResultSetRequest* request,
                       ::protobuf::ResultSet* response,
                       ::google::protobuf::Closure* done);
  virtual void commit(::google::protobuf::RpcController* controller,
                       const ::protobuf::TransactionRequest* request,
                       ::protobuf::ResultSet* response,
                       ::google::protobuf::Closure* done);
  virtual void rollback(::google::protobuf::RpcController* controller,
                       const ::protobuf::TransactionRequest* request,
                       ::protobuf::ResultSet* response,
                       ::google::protobuf::Closure* done);
  virtual void first(::google::protobuf::RpcController* controller,
                       const ::protobuf::ResultSetRequest* request,
                       ::protobuf::ResultSet* response,
                       ::google::protobuf::Closure* done);
  virtual void beforeFirst(::google::protobuf::RpcController* controller,
                       const ::protobuf::ResultSetRequest* request,
                       ::protobuf::ResultSet* response,
                       ::google::protobuf::Closure* done);
  
  // implements Service ----------------------------------------------
  
  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(CommandExecutor);
};

class CommandExecutor_Stub : public CommandExecutor {
 public:
  CommandExecutor_Stub(::google::protobuf::RpcChannel* channel);
  CommandExecutor_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~CommandExecutor_Stub();
  
  inline ::google::protobuf::RpcChannel* channel() { return channel_; }
  
  // implements CommandExecutor ------------------------------------------
  
  void ping(::google::protobuf::RpcController* controller,
                       const ::protobuf::PingRequest* request,
                       ::protobuf::ResultSet* response,
                       ::google::protobuf::Closure* done);
  void login(::google::protobuf::RpcController* controller,
                       const ::protobuf::LoginRequest* request,
                       ::protobuf::ResultSet* response,
                       ::google::protobuf::Closure* done);
  void execute(::google::protobuf::RpcController* controller,
                       const ::protobuf::CommandRequest* request,
                       ::protobuf::ResultSet* response,
                       ::google::protobuf::Closure* done);
  void fetchNext(::google::protobuf::RpcController* controller,
                       const ::protobuf::ResultSetRequest* request,
                       ::protobuf::ResultSet* response,
                       ::google::protobuf::Closure* done);
  void closeResultSet(::google::protobuf::RpcController* controller,
                       const ::protobuf::ResultSetRequest* request,
                       ::protobuf::ResultSet* response,
                       ::google::protobuf::Closure* done);
  void commit(::google::protobuf::RpcController* controller,
                       const ::protobuf::TransactionRequest* request,
                       ::protobuf::ResultSet* response,
                       ::google::protobuf::Closure* done);
  void rollback(::google::protobuf::RpcController* controller,
                       const ::protobuf::TransactionRequest* request,
                       ::protobuf::ResultSet* response,
                       ::google::protobuf::Closure* done);
  void first(::google::protobuf::RpcController* controller,
                       const ::protobuf::ResultSetRequest* request,
                       ::protobuf::ResultSet* response,
                       ::google::protobuf::Closure* done);
  void beforeFirst(::google::protobuf::RpcController* controller,
                       const ::protobuf::ResultSetRequest* request,
                       ::protobuf::ResultSet* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(CommandExecutor_Stub);
};


// ===================================================================


// ===================================================================

// Value

// optional int32 integerVal = 2;
inline bool Value::has_integerval() const {
  return _has_bit(0);
}
inline void Value::clear_integerval() {
  integerval_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Value::integerval() const {
  return integerval_;
}
inline void Value::set_integerval(::google::protobuf::int32 value) {
  _set_bit(0);
  integerval_ = value;
}

// optional int64 longVal = 3;
inline bool Value::has_longval() const {
  return _has_bit(1);
}
inline void Value::clear_longval() {
  longval_ = GOOGLE_LONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::int64 Value::longval() const {
  return longval_;
}
inline void Value::set_longval(::google::protobuf::int64 value) {
  _set_bit(1);
  longval_ = value;
}

// optional bool boolVal = 4;
inline bool Value::has_boolval() const {
  return _has_bit(2);
}
inline void Value::clear_boolval() {
  boolval_ = false;
  _clear_bit(2);
}
inline bool Value::boolval() const {
  return boolval_;
}
inline void Value::set_boolval(bool value) {
  _set_bit(2);
  boolval_ = value;
}

// optional string stringVal = 5;
inline bool Value::has_stringval() const {
  return _has_bit(3);
}
inline void Value::clear_stringval() {
  if (stringval_ != &_default_stringval_) {
    stringval_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Value::stringval() const {
  return *stringval_;
}
inline void Value::set_stringval(const ::std::string& value) {
  _set_bit(3);
  if (stringval_ == &_default_stringval_) {
    stringval_ = new ::std::string;
  }
  stringval_->assign(value);
}
inline void Value::set_stringval(const char* value) {
  _set_bit(3);
  if (stringval_ == &_default_stringval_) {
    stringval_ = new ::std::string;
  }
  stringval_->assign(value);
}
inline void Value::set_stringval(const char* value, size_t size) {
  _set_bit(3);
  if (stringval_ == &_default_stringval_) {
    stringval_ = new ::std::string;
  }
  stringval_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Value::mutable_stringval() {
  _set_bit(3);
  if (stringval_ == &_default_stringval_) {
    stringval_ = new ::std::string;
  }
  return stringval_;
}

// optional double doubleVal = 6;
inline bool Value::has_doubleval() const {
  return _has_bit(4);
}
inline void Value::clear_doubleval() {
  doubleval_ = 0;
  _clear_bit(4);
}
inline double Value::doubleval() const {
  return doubleval_;
}
inline void Value::set_doubleval(double value) {
  _set_bit(4);
  doubleval_ = value;
}

// optional float floatVal = 7;
inline bool Value::has_floatval() const {
  return _has_bit(5);
}
inline void Value::clear_floatval() {
  floatval_ = 0;
  _clear_bit(5);
}
inline float Value::floatval() const {
  return floatval_;
}
inline void Value::set_floatval(float value) {
  _set_bit(5);
  floatval_ = value;
}

// optional string charVal = 8;
inline bool Value::has_charval() const {
  return _has_bit(6);
}
inline void Value::clear_charval() {
  if (charval_ != &_default_charval_) {
    charval_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& Value::charval() const {
  return *charval_;
}
inline void Value::set_charval(const ::std::string& value) {
  _set_bit(6);
  if (charval_ == &_default_charval_) {
    charval_ = new ::std::string;
  }
  charval_->assign(value);
}
inline void Value::set_charval(const char* value) {
  _set_bit(6);
  if (charval_ == &_default_charval_) {
    charval_ = new ::std::string;
  }
  charval_->assign(value);
}
inline void Value::set_charval(const char* value, size_t size) {
  _set_bit(6);
  if (charval_ == &_default_charval_) {
    charval_ = new ::std::string;
  }
  charval_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Value::mutable_charval() {
  _set_bit(6);
  if (charval_ == &_default_charval_) {
    charval_ = new ::std::string;
  }
  return charval_;
}

// optional int32 bindVal = 9;
inline bool Value::has_bindval() const {
  return _has_bit(7);
}
inline void Value::clear_bindval() {
  bindval_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 Value::bindval() const {
  return bindval_;
}
inline void Value::set_bindval(::google::protobuf::int32 value) {
  _set_bit(7);
  bindval_ = value;
}

// optional int64 dateVal = 10;
inline bool Value::has_dateval() const {
  return _has_bit(8);
}
inline void Value::clear_dateval() {
  dateval_ = GOOGLE_LONGLONG(0);
  _clear_bit(8);
}
inline ::google::protobuf::int64 Value::dateval() const {
  return dateval_;
}
inline void Value::set_dateval(::google::protobuf::int64 value) {
  _set_bit(8);
  dateval_ = value;
}

// optional bool null = 11;
inline bool Value::has_null() const {
  return _has_bit(9);
}
inline void Value::clear_null() {
  null_ = false;
  _clear_bit(9);
}
inline bool Value::null() const {
  return null_;
}
inline void Value::set_null(bool value) {
  _set_bit(9);
  null_ = value;
}

// -------------------------------------------------------------------

// Expression

// optional .protobuf.Column column = 1;
inline bool Expression::has_column() const {
  return _has_bit(0);
}
inline void Expression::clear_column() {
  if (column_ != NULL) column_->::protobuf::Column::Clear();
  _clear_bit(0);
}
inline const ::protobuf::Column& Expression::column() const {
  return column_ != NULL ? *column_ : *default_instance_->column_;
}
inline ::protobuf::Column* Expression::mutable_column() {
  _set_bit(0);
  if (column_ == NULL) column_ = new ::protobuf::Column;
  return column_;
}

// optional .protobuf.Value value = 2;
inline bool Expression::has_value() const {
  return _has_bit(1);
}
inline void Expression::clear_value() {
  if (value_ != NULL) value_->::protobuf::Value::Clear();
  _clear_bit(1);
}
inline const ::protobuf::Value& Expression::value() const {
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::protobuf::Value* Expression::mutable_value() {
  _set_bit(1);
  if (value_ == NULL) value_ = new ::protobuf::Value;
  return value_;
}

// optional .protobuf.Function function = 3;
inline bool Expression::has_function() const {
  return _has_bit(2);
}
inline void Expression::clear_function() {
  if (function_ != NULL) function_->::protobuf::Function::Clear();
  _clear_bit(2);
}
inline const ::protobuf::Function& Expression::function() const {
  return function_ != NULL ? *function_ : *default_instance_->function_;
}
inline ::protobuf::Function* Expression::mutable_function() {
  _set_bit(2);
  if (function_ == NULL) function_ = new ::protobuf::Function;
  return function_;
}

// -------------------------------------------------------------------

// Function

// optional string functionName = 1;
inline bool Function::has_functionname() const {
  return _has_bit(0);
}
inline void Function::clear_functionname() {
  if (functionname_ != &_default_functionname_) {
    functionname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Function::functionname() const {
  return *functionname_;
}
inline void Function::set_functionname(const ::std::string& value) {
  _set_bit(0);
  if (functionname_ == &_default_functionname_) {
    functionname_ = new ::std::string;
  }
  functionname_->assign(value);
}
inline void Function::set_functionname(const char* value) {
  _set_bit(0);
  if (functionname_ == &_default_functionname_) {
    functionname_ = new ::std::string;
  }
  functionname_->assign(value);
}
inline void Function::set_functionname(const char* value, size_t size) {
  _set_bit(0);
  if (functionname_ == &_default_functionname_) {
    functionname_ = new ::std::string;
  }
  functionname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Function::mutable_functionname() {
  _set_bit(0);
  if (functionname_ == &_default_functionname_) {
    functionname_ = new ::std::string;
  }
  return functionname_;
}

// repeated .protobuf.Expression expression = 2;
inline int Function::expression_size() const {
  return expression_.size();
}
inline void Function::clear_expression() {
  expression_.Clear();
}
inline const ::protobuf::Expression& Function::expression(int index) const {
  return expression_.Get(index);
}
inline ::protobuf::Expression* Function::mutable_expression(int index) {
  return expression_.Mutable(index);
}
inline ::protobuf::Expression* Function::add_expression() {
  return expression_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >&
Function::expression() const {
  return expression_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >*
Function::mutable_expression() {
  return &expression_;
}

// optional string alias = 3;
inline bool Function::has_alias() const {
  return _has_bit(2);
}
inline void Function::clear_alias() {
  if (alias_ != &_default_alias_) {
    alias_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Function::alias() const {
  return *alias_;
}
inline void Function::set_alias(const ::std::string& value) {
  _set_bit(2);
  if (alias_ == &_default_alias_) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void Function::set_alias(const char* value) {
  _set_bit(2);
  if (alias_ == &_default_alias_) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void Function::set_alias(const char* value, size_t size) {
  _set_bit(2);
  if (alias_ == &_default_alias_) {
    alias_ = new ::std::string;
  }
  alias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Function::mutable_alias() {
  _set_bit(2);
  if (alias_ == &_default_alias_) {
    alias_ = new ::std::string;
  }
  return alias_;
}

// optional bool distinct = 4;
inline bool Function::has_distinct() const {
  return _has_bit(3);
}
inline void Function::clear_distinct() {
  distinct_ = false;
  _clear_bit(3);
}
inline bool Function::distinct() const {
  return distinct_;
}
inline void Function::set_distinct(bool value) {
  _set_bit(3);
  distinct_ = value;
}

// optional string tableName = 5;
inline bool Function::has_tablename() const {
  return _has_bit(4);
}
inline void Function::clear_tablename() {
  if (tablename_ != &_default_tablename_) {
    tablename_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& Function::tablename() const {
  return *tablename_;
}
inline void Function::set_tablename(const ::std::string& value) {
  _set_bit(4);
  if (tablename_ == &_default_tablename_) {
    tablename_ = new ::std::string;
  }
  tablename_->assign(value);
}
inline void Function::set_tablename(const char* value) {
  _set_bit(4);
  if (tablename_ == &_default_tablename_) {
    tablename_ = new ::std::string;
  }
  tablename_->assign(value);
}
inline void Function::set_tablename(const char* value, size_t size) {
  _set_bit(4);
  if (tablename_ == &_default_tablename_) {
    tablename_ = new ::std::string;
  }
  tablename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Function::mutable_tablename() {
  _set_bit(4);
  if (tablename_ == &_default_tablename_) {
    tablename_ = new ::std::string;
  }
  return tablename_;
}

// optional string columnName = 6;
inline bool Function::has_columnname() const {
  return _has_bit(5);
}
inline void Function::clear_columnname() {
  if (columnname_ != &_default_columnname_) {
    columnname_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& Function::columnname() const {
  return *columnname_;
}
inline void Function::set_columnname(const ::std::string& value) {
  _set_bit(5);
  if (columnname_ == &_default_columnname_) {
    columnname_ = new ::std::string;
  }
  columnname_->assign(value);
}
inline void Function::set_columnname(const char* value) {
  _set_bit(5);
  if (columnname_ == &_default_columnname_) {
    columnname_ = new ::std::string;
  }
  columnname_->assign(value);
}
inline void Function::set_columnname(const char* value, size_t size) {
  _set_bit(5);
  if (columnname_ == &_default_columnname_) {
    columnname_ = new ::std::string;
  }
  columnname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Function::mutable_columnname() {
  _set_bit(5);
  if (columnname_ == &_default_columnname_) {
    columnname_ = new ::std::string;
  }
  return columnname_;
}

// optional bool isNot = 7;
inline bool Function::has_isnot() const {
  return _has_bit(6);
}
inline void Function::clear_isnot() {
  isnot_ = false;
  _clear_bit(6);
}
inline bool Function::isnot() const {
  return isnot_;
}
inline void Function::set_isnot(bool value) {
  _set_bit(6);
  isnot_ = value;
}

// -------------------------------------------------------------------

// ValuesArray

// repeated .protobuf.Value values = 1;
inline int ValuesArray::values_size() const {
  return values_.size();
}
inline void ValuesArray::clear_values() {
  values_.Clear();
}
inline const ::protobuf::Value& ValuesArray::values(int index) const {
  return values_.Get(index);
}
inline ::protobuf::Value* ValuesArray::mutable_values(int index) {
  return values_.Mutable(index);
}
inline ::protobuf::Value* ValuesArray::add_values() {
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::Value >&
ValuesArray::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::Value >*
ValuesArray::mutable_values() {
  return &values_;
}

// optional bool empty = 2;
inline bool ValuesArray::has_empty() const {
  return _has_bit(1);
}
inline void ValuesArray::clear_empty() {
  empty_ = false;
  _clear_bit(1);
}
inline bool ValuesArray::empty() const {
  return empty_;
}
inline void ValuesArray::set_empty(bool value) {
  _set_bit(1);
  empty_ = value;
}

// -------------------------------------------------------------------

// ColumnsArray

// repeated .protobuf.Column columns = 1;
inline int ColumnsArray::columns_size() const {
  return columns_.size();
}
inline void ColumnsArray::clear_columns() {
  columns_.Clear();
}
inline const ::protobuf::Column& ColumnsArray::columns(int index) const {
  return columns_.Get(index);
}
inline ::protobuf::Column* ColumnsArray::mutable_columns(int index) {
  return columns_.Mutable(index);
}
inline ::protobuf::Column* ColumnsArray::add_columns() {
  return columns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::Column >&
ColumnsArray::columns() const {
  return columns_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::Column >*
ColumnsArray::mutable_columns() {
  return &columns_;
}

// -------------------------------------------------------------------

// Column

// optional string columnName = 1;
inline bool Column::has_columnname() const {
  return _has_bit(0);
}
inline void Column::clear_columnname() {
  if (columnname_ != &_default_columnname_) {
    columnname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Column::columnname() const {
  return *columnname_;
}
inline void Column::set_columnname(const ::std::string& value) {
  _set_bit(0);
  if (columnname_ == &_default_columnname_) {
    columnname_ = new ::std::string;
  }
  columnname_->assign(value);
}
inline void Column::set_columnname(const char* value) {
  _set_bit(0);
  if (columnname_ == &_default_columnname_) {
    columnname_ = new ::std::string;
  }
  columnname_->assign(value);
}
inline void Column::set_columnname(const char* value, size_t size) {
  _set_bit(0);
  if (columnname_ == &_default_columnname_) {
    columnname_ = new ::std::string;
  }
  columnname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Column::mutable_columnname() {
  _set_bit(0);
  if (columnname_ == &_default_columnname_) {
    columnname_ = new ::std::string;
  }
  return columnname_;
}

// optional .protobuf.Column.ValueType valueType = 2;
inline bool Column::has_valuetype() const {
  return _has_bit(1);
}
inline void Column::clear_valuetype() {
  valuetype_ = 1;
  _clear_bit(1);
}
inline ::protobuf::Column_ValueType Column::valuetype() const {
  return static_cast< ::protobuf::Column_ValueType >(valuetype_);
}
inline void Column::set_valuetype(::protobuf::Column_ValueType value) {
  GOOGLE_DCHECK(::protobuf::Column_ValueType_IsValid(value));
  _set_bit(1);
  valuetype_ = value;
}

// optional .protobuf.Column.AGGREGATE_FUNC aggegateFunction = 3;
inline bool Column::has_aggegatefunction() const {
  return _has_bit(2);
}
inline void Column::clear_aggegatefunction() {
  aggegatefunction_ = 1;
  _clear_bit(2);
}
inline ::protobuf::Column_AGGREGATE_FUNC Column::aggegatefunction() const {
  return static_cast< ::protobuf::Column_AGGREGATE_FUNC >(aggegatefunction_);
}
inline void Column::set_aggegatefunction(::protobuf::Column_AGGREGATE_FUNC value) {
  GOOGLE_DCHECK(::protobuf::Column_AGGREGATE_FUNC_IsValid(value));
  _set_bit(2);
  aggegatefunction_ = value;
}

// optional string alias = 4;
inline bool Column::has_alias() const {
  return _has_bit(3);
}
inline void Column::clear_alias() {
  if (alias_ != &_default_alias_) {
    alias_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Column::alias() const {
  return *alias_;
}
inline void Column::set_alias(const ::std::string& value) {
  _set_bit(3);
  if (alias_ == &_default_alias_) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void Column::set_alias(const char* value) {
  _set_bit(3);
  if (alias_ == &_default_alias_) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void Column::set_alias(const char* value, size_t size) {
  _set_bit(3);
  if (alias_ == &_default_alias_) {
    alias_ = new ::std::string;
  }
  alias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Column::mutable_alias() {
  _set_bit(3);
  if (alias_ == &_default_alias_) {
    alias_ = new ::std::string;
  }
  return alias_;
}

// optional bool distinct = 5;
inline bool Column::has_distinct() const {
  return _has_bit(4);
}
inline void Column::clear_distinct() {
  distinct_ = false;
  _clear_bit(4);
}
inline bool Column::distinct() const {
  return distinct_;
}
inline void Column::set_distinct(bool value) {
  _set_bit(4);
  distinct_ = value;
}

// optional string tablename = 6;
inline bool Column::has_tablename() const {
  return _has_bit(5);
}
inline void Column::clear_tablename() {
  if (tablename_ != &_default_tablename_) {
    tablename_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& Column::tablename() const {
  return *tablename_;
}
inline void Column::set_tablename(const ::std::string& value) {
  _set_bit(5);
  if (tablename_ == &_default_tablename_) {
    tablename_ = new ::std::string;
  }
  tablename_->assign(value);
}
inline void Column::set_tablename(const char* value) {
  _set_bit(5);
  if (tablename_ == &_default_tablename_) {
    tablename_ = new ::std::string;
  }
  tablename_->assign(value);
}
inline void Column::set_tablename(const char* value, size_t size) {
  _set_bit(5);
  if (tablename_ == &_default_tablename_) {
    tablename_ = new ::std::string;
  }
  tablename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Column::mutable_tablename() {
  _set_bit(5);
  if (tablename_ == &_default_tablename_) {
    tablename_ = new ::std::string;
  }
  return tablename_;
}

// optional bool isNot = 7;
inline bool Column::has_isnot() const {
  return _has_bit(6);
}
inline void Column::clear_isnot() {
  isnot_ = false;
  _clear_bit(6);
}
inline bool Column::isnot() const {
  return isnot_;
}
inline void Column::set_isnot(bool value) {
  _set_bit(6);
  isnot_ = value;
}

// -------------------------------------------------------------------

// OrderBy

// optional .protobuf.OrderBy.DIRECTION direction = 1;
inline bool OrderBy::has_direction() const {
  return _has_bit(0);
}
inline void OrderBy::clear_direction() {
  direction_ = 1;
  _clear_bit(0);
}
inline ::protobuf::OrderBy_DIRECTION OrderBy::direction() const {
  return static_cast< ::protobuf::OrderBy_DIRECTION >(direction_);
}
inline void OrderBy::set_direction(::protobuf::OrderBy_DIRECTION value) {
  GOOGLE_DCHECK(::protobuf::OrderBy_DIRECTION_IsValid(value));
  _set_bit(0);
  direction_ = value;
}

// optional .protobuf.Expression column = 2;
inline bool OrderBy::has_column() const {
  return _has_bit(1);
}
inline void OrderBy::clear_column() {
  if (column_ != NULL) column_->::protobuf::Expression::Clear();
  _clear_bit(1);
}
inline const ::protobuf::Expression& OrderBy::column() const {
  return column_ != NULL ? *column_ : *default_instance_->column_;
}
inline ::protobuf::Expression* OrderBy::mutable_column() {
  _set_bit(1);
  if (column_ == NULL) column_ = new ::protobuf::Expression;
  return column_;
}

// -------------------------------------------------------------------

// ResultSet

// repeated .protobuf.Expression keyColumns = 1;
inline int ResultSet::keycolumns_size() const {
  return keycolumns_.size();
}
inline void ResultSet::clear_keycolumns() {
  keycolumns_.Clear();
}
inline const ::protobuf::Expression& ResultSet::keycolumns(int index) const {
  return keycolumns_.Get(index);
}
inline ::protobuf::Expression* ResultSet::mutable_keycolumns(int index) {
  return keycolumns_.Mutable(index);
}
inline ::protobuf::Expression* ResultSet::add_keycolumns() {
  return keycolumns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >&
ResultSet::keycolumns() const {
  return keycolumns_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >*
ResultSet::mutable_keycolumns() {
  return &keycolumns_;
}

// repeated .protobuf.ValuesArray keyRows = 2;
inline int ResultSet::keyrows_size() const {
  return keyrows_.size();
}
inline void ResultSet::clear_keyrows() {
  keyrows_.Clear();
}
inline const ::protobuf::ValuesArray& ResultSet::keyrows(int index) const {
  return keyrows_.Get(index);
}
inline ::protobuf::ValuesArray* ResultSet::mutable_keyrows(int index) {
  return keyrows_.Mutable(index);
}
inline ::protobuf::ValuesArray* ResultSet::add_keyrows() {
  return keyrows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::ValuesArray >&
ResultSet::keyrows() const {
  return keyrows_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::ValuesArray >*
ResultSet::mutable_keyrows() {
  return &keyrows_;
}

// optional string exception = 3;
inline bool ResultSet::has_exception() const {
  return _has_bit(2);
}
inline void ResultSet::clear_exception() {
  if (exception_ != &_default_exception_) {
    exception_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& ResultSet::exception() const {
  return *exception_;
}
inline void ResultSet::set_exception(const ::std::string& value) {
  _set_bit(2);
  if (exception_ == &_default_exception_) {
    exception_ = new ::std::string;
  }
  exception_->assign(value);
}
inline void ResultSet::set_exception(const char* value) {
  _set_bit(2);
  if (exception_ == &_default_exception_) {
    exception_ = new ::std::string;
  }
  exception_->assign(value);
}
inline void ResultSet::set_exception(const char* value, size_t size) {
  _set_bit(2);
  if (exception_ == &_default_exception_) {
    exception_ = new ::std::string;
  }
  exception_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResultSet::mutable_exception() {
  _set_bit(2);
  if (exception_ == &_default_exception_) {
    exception_ = new ::std::string;
  }
  return exception_;
}

// optional int64 transactionId = 4;
inline bool ResultSet::has_transactionid() const {
  return _has_bit(3);
}
inline void ResultSet::clear_transactionid() {
  transactionid_ = GOOGLE_LONGLONG(0);
  _clear_bit(3);
}
inline ::google::protobuf::int64 ResultSet::transactionid() const {
  return transactionid_;
}
inline void ResultSet::set_transactionid(::google::protobuf::int64 value) {
  _set_bit(3);
  transactionid_ = value;
}

// optional int32 resultSetId = 5;
inline bool ResultSet::has_resultsetid() const {
  return _has_bit(4);
}
inline void ResultSet::clear_resultsetid() {
  resultsetid_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 ResultSet::resultsetid() const {
  return resultsetid_;
}
inline void ResultSet::set_resultsetid(::google::protobuf::int32 value) {
  _set_bit(4);
  resultsetid_ = value;
}

// optional bool success = 6;
inline bool ResultSet::has_success() const {
  return _has_bit(5);
}
inline void ResultSet::clear_success() {
  success_ = false;
  _clear_bit(5);
}
inline bool ResultSet::success() const {
  return success_;
}
inline void ResultSet::set_success(bool value) {
  _set_bit(5);
  success_ = value;
}

// repeated .protobuf.Expression valColumns = 7;
inline int ResultSet::valcolumns_size() const {
  return valcolumns_.size();
}
inline void ResultSet::clear_valcolumns() {
  valcolumns_.Clear();
}
inline const ::protobuf::Expression& ResultSet::valcolumns(int index) const {
  return valcolumns_.Get(index);
}
inline ::protobuf::Expression* ResultSet::mutable_valcolumns(int index) {
  return valcolumns_.Mutable(index);
}
inline ::protobuf::Expression* ResultSet::add_valcolumns() {
  return valcolumns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >&
ResultSet::valcolumns() const {
  return valcolumns_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >*
ResultSet::mutable_valcolumns() {
  return &valcolumns_;
}

// repeated .protobuf.ValuesArray valRows = 8;
inline int ResultSet::valrows_size() const {
  return valrows_.size();
}
inline void ResultSet::clear_valrows() {
  valrows_.Clear();
}
inline const ::protobuf::ValuesArray& ResultSet::valrows(int index) const {
  return valrows_.Get(index);
}
inline ::protobuf::ValuesArray* ResultSet::mutable_valrows(int index) {
  return valrows_.Mutable(index);
}
inline ::protobuf::ValuesArray* ResultSet::add_valrows() {
  return valrows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::ValuesArray >&
ResultSet::valrows() const {
  return valrows_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::ValuesArray >*
ResultSet::mutable_valrows() {
  return &valrows_;
}

// optional .protobuf.ExtraMsg extraRouteMsg = 9;
inline bool ResultSet::has_extraroutemsg() const {
  return _has_bit(8);
}
inline void ResultSet::clear_extraroutemsg() {
  if (extraroutemsg_ != NULL) extraroutemsg_->::protobuf::ExtraMsg::Clear();
  _clear_bit(8);
}
inline const ::protobuf::ExtraMsg& ResultSet::extraroutemsg() const {
  return extraroutemsg_ != NULL ? *extraroutemsg_ : *default_instance_->extraroutemsg_;
}
inline ::protobuf::ExtraMsg* ResultSet::mutable_extraroutemsg() {
  _set_bit(8);
  if (extraroutemsg_ == NULL) extraroutemsg_ = new ::protobuf::ExtraMsg;
  return extraroutemsg_;
}

// repeated .protobuf.OrderBy orderBy = 10;
inline int ResultSet::orderby_size() const {
  return orderby_.size();
}
inline void ResultSet::clear_orderby() {
  orderby_.Clear();
}
inline const ::protobuf::OrderBy& ResultSet::orderby(int index) const {
  return orderby_.Get(index);
}
inline ::protobuf::OrderBy* ResultSet::mutable_orderby(int index) {
  return orderby_.Mutable(index);
}
inline ::protobuf::OrderBy* ResultSet::add_orderby() {
  return orderby_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::OrderBy >&
ResultSet::orderby() const {
  return orderby_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::OrderBy >*
ResultSet::mutable_orderby() {
  return &orderby_;
}

// repeated .protobuf.Expression selectionColumn = 11;
inline int ResultSet::selectioncolumn_size() const {
  return selectioncolumn_.size();
}
inline void ResultSet::clear_selectioncolumn() {
  selectioncolumn_.Clear();
}
inline const ::protobuf::Expression& ResultSet::selectioncolumn(int index) const {
  return selectioncolumn_.Get(index);
}
inline ::protobuf::Expression* ResultSet::mutable_selectioncolumn(int index) {
  return selectioncolumn_.Mutable(index);
}
inline ::protobuf::Expression* ResultSet::add_selectioncolumn() {
  return selectioncolumn_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >&
ResultSet::selectioncolumn() const {
  return selectioncolumn_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >*
ResultSet::mutable_selectioncolumn() {
  return &selectioncolumn_;
}

// -------------------------------------------------------------------

// ExtraMsg

// repeated string extraRouteKey = 1;
inline int ExtraMsg::extraroutekey_size() const {
  return extraroutekey_.size();
}
inline void ExtraMsg::clear_extraroutekey() {
  extraroutekey_.Clear();
}
inline const ::std::string& ExtraMsg::extraroutekey(int index) const {
  return extraroutekey_.Get(index);
}
inline ::std::string* ExtraMsg::mutable_extraroutekey(int index) {
  return extraroutekey_.Mutable(index);
}
inline void ExtraMsg::set_extraroutekey(int index, const ::std::string& value) {
  extraroutekey_.Mutable(index)->assign(value);
}
inline void ExtraMsg::set_extraroutekey(int index, const char* value) {
  extraroutekey_.Mutable(index)->assign(value);
}
inline void ExtraMsg::set_extraroutekey(int index, const char* value, size_t size) {
  extraroutekey_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExtraMsg::add_extraroutekey() {
  return extraroutekey_.Add();
}
inline void ExtraMsg::add_extraroutekey(const ::std::string& value) {
  extraroutekey_.Add()->assign(value);
}
inline void ExtraMsg::add_extraroutekey(const char* value) {
  extraroutekey_.Add()->assign(value);
}
inline void ExtraMsg::add_extraroutekey(const char* value, size_t size) {
  extraroutekey_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ExtraMsg::extraroutekey() const {
  return extraroutekey_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ExtraMsg::mutable_extraroutekey() {
  return &extraroutekey_;
}

// optional .protobuf.ValuesArray extraRouteValue = 2;
inline bool ExtraMsg::has_extraroutevalue() const {
  return _has_bit(1);
}
inline void ExtraMsg::clear_extraroutevalue() {
  if (extraroutevalue_ != NULL) extraroutevalue_->::protobuf::ValuesArray::Clear();
  _clear_bit(1);
}
inline const ::protobuf::ValuesArray& ExtraMsg::extraroutevalue() const {
  return extraroutevalue_ != NULL ? *extraroutevalue_ : *default_instance_->extraroutevalue_;
}
inline ::protobuf::ValuesArray* ExtraMsg::mutable_extraroutevalue() {
  _set_bit(1);
  if (extraroutevalue_ == NULL) extraroutevalue_ = new ::protobuf::ValuesArray;
  return extraroutevalue_;
}

// -------------------------------------------------------------------

// QueryCommon

// repeated .protobuf.OrderBy orderBy = 1;
inline int QueryCommon::orderby_size() const {
  return orderby_.size();
}
inline void QueryCommon::clear_orderby() {
  orderby_.Clear();
}
inline const ::protobuf::OrderBy& QueryCommon::orderby(int index) const {
  return orderby_.Get(index);
}
inline ::protobuf::OrderBy* QueryCommon::mutable_orderby(int index) {
  return orderby_.Mutable(index);
}
inline ::protobuf::OrderBy* QueryCommon::add_orderby() {
  return orderby_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::OrderBy >&
QueryCommon::orderby() const {
  return orderby_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::OrderBy >*
QueryCommon::mutable_orderby() {
  return &orderby_;
}

// optional int64 limitFrom = 2;
inline bool QueryCommon::has_limitfrom() const {
  return _has_bit(1);
}
inline void QueryCommon::clear_limitfrom() {
  limitfrom_ = GOOGLE_LONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::int64 QueryCommon::limitfrom() const {
  return limitfrom_;
}
inline void QueryCommon::set_limitfrom(::google::protobuf::int64 value) {
  _set_bit(1);
  limitfrom_ = value;
}

// optional int64 limitTo = 3;
inline bool QueryCommon::has_limitto() const {
  return _has_bit(2);
}
inline void QueryCommon::clear_limitto() {
  limitto_ = GOOGLE_LONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::int64 QueryCommon::limitto() const {
  return limitto_;
}
inline void QueryCommon::set_limitto(::google::protobuf::int64 value) {
  _set_bit(2);
  limitto_ = value;
}

// optional .protobuf.Filter valueFilters = 4;
inline bool QueryCommon::has_valuefilters() const {
  return _has_bit(3);
}
inline void QueryCommon::clear_valuefilters() {
  if (valuefilters_ != NULL) valuefilters_->::protobuf::Filter::Clear();
  _clear_bit(3);
}
inline const ::protobuf::Filter& QueryCommon::valuefilters() const {
  return valuefilters_ != NULL ? *valuefilters_ : *default_instance_->valuefilters_;
}
inline ::protobuf::Filter* QueryCommon::mutable_valuefilters() {
  _set_bit(3);
  if (valuefilters_ == NULL) valuefilters_ = new ::protobuf::Filter;
  return valuefilters_;
}

// repeated .protobuf.Expression selectionColumn = 5;
inline int QueryCommon::selectioncolumn_size() const {
  return selectioncolumn_.size();
}
inline void QueryCommon::clear_selectioncolumn() {
  selectioncolumn_.Clear();
}
inline const ::protobuf::Expression& QueryCommon::selectioncolumn(int index) const {
  return selectioncolumn_.Get(index);
}
inline ::protobuf::Expression* QueryCommon::mutable_selectioncolumn(int index) {
  return selectioncolumn_.Mutable(index);
}
inline ::protobuf::Expression* QueryCommon::add_selectioncolumn() {
  return selectioncolumn_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >&
QueryCommon::selectioncolumn() const {
  return selectioncolumn_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >*
QueryCommon::mutable_selectioncolumn() {
  return &selectioncolumn_;
}

// repeated .protobuf.OrderBy groupBy = 6;
inline int QueryCommon::groupby_size() const {
  return groupby_.size();
}
inline void QueryCommon::clear_groupby() {
  groupby_.Clear();
}
inline const ::protobuf::OrderBy& QueryCommon::groupby(int index) const {
  return groupby_.Get(index);
}
inline ::protobuf::OrderBy* QueryCommon::mutable_groupby(int index) {
  return groupby_.Mutable(index);
}
inline ::protobuf::OrderBy* QueryCommon::add_groupby() {
  return groupby_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::OrderBy >&
QueryCommon::groupby() const {
  return groupby_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::OrderBy >*
QueryCommon::mutable_groupby() {
  return &groupby_;
}

// optional .protobuf.Filter keyFilter = 7;
inline bool QueryCommon::has_keyfilter() const {
  return _has_bit(6);
}
inline void QueryCommon::clear_keyfilter() {
  if (keyfilter_ != NULL) keyfilter_->::protobuf::Filter::Clear();
  _clear_bit(6);
}
inline const ::protobuf::Filter& QueryCommon::keyfilter() const {
  return keyfilter_ != NULL ? *keyfilter_ : *default_instance_->keyfilter_;
}
inline ::protobuf::Filter* QueryCommon::mutable_keyfilter() {
  _set_bit(6);
  if (keyfilter_ == NULL) keyfilter_ = new ::protobuf::Filter;
  return keyfilter_;
}

// optional string idxName = 8;
inline bool QueryCommon::has_idxname() const {
  return _has_bit(7);
}
inline void QueryCommon::clear_idxname() {
  if (idxname_ != &_default_idxname_) {
    idxname_->clear();
  }
  _clear_bit(7);
}
inline const ::std::string& QueryCommon::idxname() const {
  return *idxname_;
}
inline void QueryCommon::set_idxname(const ::std::string& value) {
  _set_bit(7);
  if (idxname_ == &_default_idxname_) {
    idxname_ = new ::std::string;
  }
  idxname_->assign(value);
}
inline void QueryCommon::set_idxname(const char* value) {
  _set_bit(7);
  if (idxname_ == &_default_idxname_) {
    idxname_ = new ::std::string;
  }
  idxname_->assign(value);
}
inline void QueryCommon::set_idxname(const char* value, size_t size) {
  _set_bit(7);
  if (idxname_ == &_default_idxname_) {
    idxname_ = new ::std::string;
  }
  idxname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryCommon::mutable_idxname() {
  _set_bit(7);
  if (idxname_ == &_default_idxname_) {
    idxname_ = new ::std::string;
  }
  return idxname_;
}

// optional .protobuf.QueryCommon.PlanType planNodeType = 9;
inline bool QueryCommon::has_plannodetype() const {
  return _has_bit(8);
}
inline void QueryCommon::clear_plannodetype() {
  plannodetype_ = 1;
  _clear_bit(8);
}
inline ::protobuf::QueryCommon_PlanType QueryCommon::plannodetype() const {
  return static_cast< ::protobuf::QueryCommon_PlanType >(plannodetype_);
}
inline void QueryCommon::set_plannodetype(::protobuf::QueryCommon_PlanType value) {
  GOOGLE_DCHECK(::protobuf::QueryCommon_PlanType_IsValid(value));
  _set_bit(8);
  plannodetype_ = value;
}

// repeated .protobuf.CommandNode subNodes = 10;
inline int QueryCommon::subnodes_size() const {
  return subnodes_.size();
}
inline void QueryCommon::clear_subnodes() {
  subnodes_.Clear();
}
inline const ::protobuf::CommandNode& QueryCommon::subnodes(int index) const {
  return subnodes_.Get(index);
}
inline ::protobuf::CommandNode* QueryCommon::mutable_subnodes(int index) {
  return subnodes_.Mutable(index);
}
inline ::protobuf::CommandNode* QueryCommon::add_subnodes() {
  return subnodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::CommandNode >&
QueryCommon::subnodes() const {
  return subnodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::CommandNode >*
QueryCommon::mutable_subnodes() {
  return &subnodes_;
}

// optional string dataNodeKey = 12;
inline bool QueryCommon::has_datanodekey() const {
  return _has_bit(10);
}
inline void QueryCommon::clear_datanodekey() {
  if (datanodekey_ != &_default_datanodekey_) {
    datanodekey_->clear();
  }
  _clear_bit(10);
}
inline const ::std::string& QueryCommon::datanodekey() const {
  return *datanodekey_;
}
inline void QueryCommon::set_datanodekey(const ::std::string& value) {
  _set_bit(10);
  if (datanodekey_ == &_default_datanodekey_) {
    datanodekey_ = new ::std::string;
  }
  datanodekey_->assign(value);
}
inline void QueryCommon::set_datanodekey(const char* value) {
  _set_bit(10);
  if (datanodekey_ == &_default_datanodekey_) {
    datanodekey_ = new ::std::string;
  }
  datanodekey_->assign(value);
}
inline void QueryCommon::set_datanodekey(const char* value, size_t size) {
  _set_bit(10);
  if (datanodekey_ == &_default_datanodekey_) {
    datanodekey_ = new ::std::string;
  }
  datanodekey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryCommon::mutable_datanodekey() {
  _set_bit(10);
  if (datanodekey_ == &_default_datanodekey_) {
    datanodekey_ = new ::std::string;
  }
  return datanodekey_;
}

// optional .protobuf.QueryCommon.LockModel lockModel = 13;
inline bool QueryCommon::has_lockmodel() const {
  return _has_bit(11);
}
inline void QueryCommon::clear_lockmodel() {
  lockmodel_ = 1;
  _clear_bit(11);
}
inline ::protobuf::QueryCommon_LockModel QueryCommon::lockmodel() const {
  return static_cast< ::protobuf::QueryCommon_LockModel >(lockmodel_);
}
inline void QueryCommon::set_lockmodel(::protobuf::QueryCommon_LockModel value) {
  GOOGLE_DCHECK(::protobuf::QueryCommon_LockModel_IsValid(value));
  _set_bit(11);
  lockmodel_ = value;
}

// optional bool consistentRead = 14;
inline bool QueryCommon::has_consistentread() const {
  return _has_bit(12);
}
inline void QueryCommon::clear_consistentread() {
  consistentread_ = false;
  _clear_bit(12);
}
inline bool QueryCommon::consistentread() const {
  return consistentread_;
}
inline void QueryCommon::set_consistentread(bool value) {
  _set_bit(12);
  consistentread_ = value;
}

// optional .protobuf.QueryCommon.QUERY_CONCURRENCY queryConcurrency = 15;
inline bool QueryCommon::has_queryconcurrency() const {
  return _has_bit(13);
}
inline void QueryCommon::clear_queryconcurrency() {
  queryconcurrency_ = 1;
  _clear_bit(13);
}
inline ::protobuf::QueryCommon_QUERY_CONCURRENCY QueryCommon::queryconcurrency() const {
  return static_cast< ::protobuf::QueryCommon_QUERY_CONCURRENCY >(queryconcurrency_);
}
inline void QueryCommon::set_queryconcurrency(::protobuf::QueryCommon_QUERY_CONCURRENCY value) {
  GOOGLE_DCHECK(::protobuf::QueryCommon_QUERY_CONCURRENCY_IsValid(value));
  _set_bit(13);
  queryconcurrency_ = value;
}

// optional bool leftOuter = 16;
inline bool QueryCommon::has_leftouter() const {
  return _has_bit(14);
}
inline void QueryCommon::clear_leftouter() {
  leftouter_ = false;
  _clear_bit(14);
}
inline bool QueryCommon::leftouter() const {
  return leftouter_;
}
inline void QueryCommon::set_leftouter(bool value) {
  _set_bit(14);
  leftouter_ = value;
}

// optional bool rightOuter = 17;
inline bool QueryCommon::has_rightouter() const {
  return _has_bit(15);
}
inline void QueryCommon::clear_rightouter() {
  rightouter_ = false;
  _clear_bit(15);
}
inline bool QueryCommon::rightouter() const {
  return rightouter_;
}
inline void QueryCommon::set_rightouter(bool value) {
  _set_bit(15);
  rightouter_ = value;
}

// repeated .protobuf.Column rightJoinOnColumn = 18;
inline int QueryCommon::rightjoinoncolumn_size() const {
  return rightjoinoncolumn_.size();
}
inline void QueryCommon::clear_rightjoinoncolumn() {
  rightjoinoncolumn_.Clear();
}
inline const ::protobuf::Column& QueryCommon::rightjoinoncolumn(int index) const {
  return rightjoinoncolumn_.Get(index);
}
inline ::protobuf::Column* QueryCommon::mutable_rightjoinoncolumn(int index) {
  return rightjoinoncolumn_.Mutable(index);
}
inline ::protobuf::Column* QueryCommon::add_rightjoinoncolumn() {
  return rightjoinoncolumn_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::Column >&
QueryCommon::rightjoinoncolumn() const {
  return rightjoinoncolumn_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::Column >*
QueryCommon::mutable_rightjoinoncolumn() {
  return &rightjoinoncolumn_;
}

// repeated .protobuf.Column leftJoinOnColumn = 19;
inline int QueryCommon::leftjoinoncolumn_size() const {
  return leftjoinoncolumn_.size();
}
inline void QueryCommon::clear_leftjoinoncolumn() {
  leftjoinoncolumn_.Clear();
}
inline const ::protobuf::Column& QueryCommon::leftjoinoncolumn(int index) const {
  return leftjoinoncolumn_.Get(index);
}
inline ::protobuf::Column* QueryCommon::mutable_leftjoinoncolumn(int index) {
  return leftjoinoncolumn_.Mutable(index);
}
inline ::protobuf::Column* QueryCommon::add_leftjoinoncolumn() {
  return leftjoinoncolumn_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::Column >&
QueryCommon::leftjoinoncolumn() const {
  return leftjoinoncolumn_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::Column >*
QueryCommon::mutable_leftjoinoncolumn() {
  return &leftjoinoncolumn_;
}

// optional string alias = 20;
inline bool QueryCommon::has_alias() const {
  return _has_bit(18);
}
inline void QueryCommon::clear_alias() {
  if (alias_ != &_default_alias_) {
    alias_->clear();
  }
  _clear_bit(18);
}
inline const ::std::string& QueryCommon::alias() const {
  return *alias_;
}
inline void QueryCommon::set_alias(const ::std::string& value) {
  _set_bit(18);
  if (alias_ == &_default_alias_) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void QueryCommon::set_alias(const char* value) {
  _set_bit(18);
  if (alias_ == &_default_alias_) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void QueryCommon::set_alias(const char* value, size_t size) {
  _set_bit(18);
  if (alias_ == &_default_alias_) {
    alias_ = new ::std::string;
  }
  alias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryCommon::mutable_alias() {
  _set_bit(18);
  if (alias_ == &_default_alias_) {
    alias_ = new ::std::string;
  }
  return alias_;
}

// optional int64 requestID = 21;
inline bool QueryCommon::has_requestid() const {
  return _has_bit(19);
}
inline void QueryCommon::clear_requestid() {
  requestid_ = GOOGLE_LONGLONG(0);
  _clear_bit(19);
}
inline ::google::protobuf::int64 QueryCommon::requestid() const {
  return requestid_;
}
inline void QueryCommon::set_requestid(::google::protobuf::int64 value) {
  _set_bit(19);
  requestid_ = value;
}

// optional string requestHostName = 22;
inline bool QueryCommon::has_requesthostname() const {
  return _has_bit(20);
}
inline void QueryCommon::clear_requesthostname() {
  if (requesthostname_ != &_default_requesthostname_) {
    requesthostname_->clear();
  }
  _clear_bit(20);
}
inline const ::std::string& QueryCommon::requesthostname() const {
  return *requesthostname_;
}
inline void QueryCommon::set_requesthostname(const ::std::string& value) {
  _set_bit(20);
  if (requesthostname_ == &_default_requesthostname_) {
    requesthostname_ = new ::std::string;
  }
  requesthostname_->assign(value);
}
inline void QueryCommon::set_requesthostname(const char* value) {
  _set_bit(20);
  if (requesthostname_ == &_default_requesthostname_) {
    requesthostname_ = new ::std::string;
  }
  requesthostname_->assign(value);
}
inline void QueryCommon::set_requesthostname(const char* value, size_t size) {
  _set_bit(20);
  if (requesthostname_ == &_default_requesthostname_) {
    requesthostname_ = new ::std::string;
  }
  requesthostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryCommon::mutable_requesthostname() {
  _set_bit(20);
  if (requesthostname_ == &_default_requesthostname_) {
    requesthostname_ = new ::std::string;
  }
  return requesthostname_;
}

// optional int32 subRequestID = 23;
inline bool QueryCommon::has_subrequestid() const {
  return _has_bit(21);
}
inline void QueryCommon::clear_subrequestid() {
  subrequestid_ = 0;
  _clear_bit(21);
}
inline ::google::protobuf::int32 QueryCommon::subrequestid() const {
  return subrequestid_;
}
inline void QueryCommon::set_subrequestid(::google::protobuf::int32 value) {
  _set_bit(21);
  subrequestid_ = value;
}

// optional int32 thread = 24;
inline bool QueryCommon::has_thread() const {
  return _has_bit(22);
}
inline void QueryCommon::clear_thread() {
  thread_ = 0;
  _clear_bit(22);
}
inline ::google::protobuf::int32 QueryCommon::thread() const {
  return thread_;
}
inline void QueryCommon::set_thread(::google::protobuf::int32 value) {
  _set_bit(22);
  thread_ = value;
}

// optional bool sharded = 25;
inline bool QueryCommon::has_sharded() const {
  return _has_bit(23);
}
inline void QueryCommon::clear_sharded() {
  sharded_ = false;
  _clear_bit(23);
}
inline bool QueryCommon::sharded() const {
  return sharded_;
}
inline void QueryCommon::set_sharded(bool value) {
  _set_bit(23);
  sharded_ = value;
}

// optional bool canMerge = 26;
inline bool QueryCommon::has_canmerge() const {
  return _has_bit(24);
}
inline void QueryCommon::clear_canmerge() {
  canmerge_ = false;
  _clear_bit(24);
}
inline bool QueryCommon::canmerge() const {
  return canmerge_;
}
inline void QueryCommon::set_canmerge(bool value) {
  _set_bit(24);
  canmerge_ = value;
}

// optional bool useTempTableExplicit = 27;
inline bool QueryCommon::has_usetemptableexplicit() const {
  return _has_bit(25);
}
inline void QueryCommon::clear_usetemptableexplicit() {
  usetemptableexplicit_ = false;
  _clear_bit(25);
}
inline bool QueryCommon::usetemptableexplicit() const {
  return usetemptableexplicit_;
}
inline void QueryCommon::set_usetemptableexplicit(bool value) {
  _set_bit(25);
  usetemptableexplicit_ = value;
}

// optional string actualTable = 28;
inline bool QueryCommon::has_actualtable() const {
  return _has_bit(26);
}
inline void QueryCommon::clear_actualtable() {
  if (actualtable_ != &_default_actualtable_) {
    actualtable_->clear();
  }
  _clear_bit(26);
}
inline const ::std::string& QueryCommon::actualtable() const {
  return *actualtable_;
}
inline void QueryCommon::set_actualtable(const ::std::string& value) {
  _set_bit(26);
  if (actualtable_ == &_default_actualtable_) {
    actualtable_ = new ::std::string;
  }
  actualtable_->assign(value);
}
inline void QueryCommon::set_actualtable(const char* value) {
  _set_bit(26);
  if (actualtable_ == &_default_actualtable_) {
    actualtable_ = new ::std::string;
  }
  actualtable_->assign(value);
}
inline void QueryCommon::set_actualtable(const char* value, size_t size) {
  _set_bit(26);
  if (actualtable_ == &_default_actualtable_) {
    actualtable_ = new ::std::string;
  }
  actualtable_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryCommon::mutable_actualtable() {
  _set_bit(26);
  if (actualtable_ == &_default_actualtable_) {
    actualtable_ = new ::std::string;
  }
  return actualtable_;
}

// optional bool isSubQuery = 29;
inline bool QueryCommon::has_issubquery() const {
  return _has_bit(27);
}
inline void QueryCommon::clear_issubquery() {
  issubquery_ = false;
  _clear_bit(27);
}
inline bool QueryCommon::issubquery() const {
  return issubquery_;
}
inline void QueryCommon::set_issubquery(bool value) {
  _set_bit(27);
  issubquery_ = value;
}

// optional bool isUnion = 30;
inline bool QueryCommon::has_isunion() const {
  return _has_bit(28);
}
inline void QueryCommon::clear_isunion() {
  isunion_ = false;
  _clear_bit(28);
}
inline bool QueryCommon::isunion() const {
  return isunion_;
}
inline void QueryCommon::set_isunion(bool value) {
  _set_bit(28);
  isunion_ = value;
}

// optional .protobuf.Filter otherJoinFilter = 31;
inline bool QueryCommon::has_otherjoinfilter() const {
  return _has_bit(29);
}
inline void QueryCommon::clear_otherjoinfilter() {
  if (otherjoinfilter_ != NULL) otherjoinfilter_->::protobuf::Filter::Clear();
  _clear_bit(29);
}
inline const ::protobuf::Filter& QueryCommon::otherjoinfilter() const {
  return otherjoinfilter_ != NULL ? *otherjoinfilter_ : *default_instance_->otherjoinfilter_;
}
inline ::protobuf::Filter* QueryCommon::mutable_otherjoinfilter() {
  _set_bit(29);
  if (otherjoinfilter_ == NULL) otherjoinfilter_ = new ::protobuf::Filter;
  return otherjoinfilter_;
}

// -------------------------------------------------------------------

// Put

// optional .protobuf.QueryCommon queryCommon = 1;
inline bool Put::has_querycommon() const {
  return _has_bit(0);
}
inline void Put::clear_querycommon() {
  if (querycommon_ != NULL) querycommon_->::protobuf::QueryCommon::Clear();
  _clear_bit(0);
}
inline const ::protobuf::QueryCommon& Put::querycommon() const {
  return querycommon_ != NULL ? *querycommon_ : *default_instance_->querycommon_;
}
inline ::protobuf::QueryCommon* Put::mutable_querycommon() {
  _set_bit(0);
  if (querycommon_ == NULL) querycommon_ = new ::protobuf::QueryCommon;
  return querycommon_;
}

// repeated .protobuf.Expression columns = 2;
inline int Put::columns_size() const {
  return columns_.size();
}
inline void Put::clear_columns() {
  columns_.Clear();
}
inline const ::protobuf::Expression& Put::columns(int index) const {
  return columns_.Get(index);
}
inline ::protobuf::Expression* Put::mutable_columns(int index) {
  return columns_.Mutable(index);
}
inline ::protobuf::Expression* Put::add_columns() {
  return columns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >&
Put::columns() const {
  return columns_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >*
Put::mutable_columns() {
  return &columns_;
}

// optional string indexName = 3;
inline bool Put::has_indexname() const {
  return _has_bit(2);
}
inline void Put::clear_indexname() {
  if (indexname_ != &_default_indexname_) {
    indexname_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Put::indexname() const {
  return *indexname_;
}
inline void Put::set_indexname(const ::std::string& value) {
  _set_bit(2);
  if (indexname_ == &_default_indexname_) {
    indexname_ = new ::std::string;
  }
  indexname_->assign(value);
}
inline void Put::set_indexname(const char* value) {
  _set_bit(2);
  if (indexname_ == &_default_indexname_) {
    indexname_ = new ::std::string;
  }
  indexname_->assign(value);
}
inline void Put::set_indexname(const char* value, size_t size) {
  _set_bit(2);
  if (indexname_ == &_default_indexname_) {
    indexname_ = new ::std::string;
  }
  indexname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Put::mutable_indexname() {
  _set_bit(2);
  if (indexname_ == &_default_indexname_) {
    indexname_ = new ::std::string;
  }
  return indexname_;
}

// optional .protobuf.Put.PUT_TYPE putType = 4;
inline bool Put::has_puttype() const {
  return _has_bit(3);
}
inline void Put::clear_puttype() {
  puttype_ = 1;
  _clear_bit(3);
}
inline ::protobuf::Put_PUT_TYPE Put::puttype() const {
  return static_cast< ::protobuf::Put_PUT_TYPE >(puttype_);
}
inline void Put::set_puttype(::protobuf::Put_PUT_TYPE value) {
  GOOGLE_DCHECK(::protobuf::Put_PUT_TYPE_IsValid(value));
  _set_bit(3);
  puttype_ = value;
}

// repeated .protobuf.Expression updateVal = 5;
inline int Put::updateval_size() const {
  return updateval_.size();
}
inline void Put::clear_updateval() {
  updateval_.Clear();
}
inline const ::protobuf::Expression& Put::updateval(int index) const {
  return updateval_.Get(index);
}
inline ::protobuf::Expression* Put::mutable_updateval(int index) {
  return updateval_.Mutable(index);
}
inline ::protobuf::Expression* Put::add_updateval() {
  return updateval_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >&
Put::updateval() const {
  return updateval_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >*
Put::mutable_updateval() {
  return &updateval_;
}

// optional string dataNodeKey = 6;
inline bool Put::has_datanodekey() const {
  return _has_bit(5);
}
inline void Put::clear_datanodekey() {
  if (datanodekey_ != &_default_datanodekey_) {
    datanodekey_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& Put::datanodekey() const {
  return *datanodekey_;
}
inline void Put::set_datanodekey(const ::std::string& value) {
  _set_bit(5);
  if (datanodekey_ == &_default_datanodekey_) {
    datanodekey_ = new ::std::string;
  }
  datanodekey_->assign(value);
}
inline void Put::set_datanodekey(const char* value) {
  _set_bit(5);
  if (datanodekey_ == &_default_datanodekey_) {
    datanodekey_ = new ::std::string;
  }
  datanodekey_->assign(value);
}
inline void Put::set_datanodekey(const char* value, size_t size) {
  _set_bit(5);
  if (datanodekey_ == &_default_datanodekey_) {
    datanodekey_ = new ::std::string;
  }
  datanodekey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Put::mutable_datanodekey() {
  _set_bit(5);
  if (datanodekey_ == &_default_datanodekey_) {
    datanodekey_ = new ::std::string;
  }
  return datanodekey_;
}

// optional int32 thread = 7;
inline bool Put::has_thread() const {
  return _has_bit(6);
}
inline void Put::clear_thread() {
  thread_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 Put::thread() const {
  return thread_;
}
inline void Put::set_thread(::google::protobuf::int32 value) {
  _set_bit(6);
  thread_ = value;
}

// optional string indexKey = 8;
inline bool Put::has_indexkey() const {
  return _has_bit(7);
}
inline void Put::clear_indexkey() {
  if (indexkey_ != &_default_indexkey_) {
    indexkey_->clear();
  }
  _clear_bit(7);
}
inline const ::std::string& Put::indexkey() const {
  return *indexkey_;
}
inline void Put::set_indexkey(const ::std::string& value) {
  _set_bit(7);
  if (indexkey_ == &_default_indexkey_) {
    indexkey_ = new ::std::string;
  }
  indexkey_->assign(value);
}
inline void Put::set_indexkey(const char* value) {
  _set_bit(7);
  if (indexkey_ == &_default_indexkey_) {
    indexkey_ = new ::std::string;
  }
  indexkey_->assign(value);
}
inline void Put::set_indexkey(const char* value, size_t size) {
  _set_bit(7);
  if (indexkey_ == &_default_indexkey_) {
    indexkey_ = new ::std::string;
  }
  indexkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Put::mutable_indexkey() {
  _set_bit(7);
  if (indexkey_ == &_default_indexkey_) {
    indexkey_ = new ::std::string;
  }
  return indexkey_;
}

// -------------------------------------------------------------------

// Filter

// optional .protobuf.Expression column = 1;
inline bool Filter::has_column() const {
  return _has_bit(0);
}
inline void Filter::clear_column() {
  if (column_ != NULL) column_->::protobuf::Expression::Clear();
  _clear_bit(0);
}
inline const ::protobuf::Expression& Filter::column() const {
  return column_ != NULL ? *column_ : *default_instance_->column_;
}
inline ::protobuf::Expression* Filter::mutable_column() {
  _set_bit(0);
  if (column_ == NULL) column_ = new ::protobuf::Expression;
  return column_;
}

// optional .protobuf.Filter.AccessType accessType = 2;
inline bool Filter::has_accesstype() const {
  return _has_bit(1);
}
inline void Filter::clear_accesstype() {
  accesstype_ = 1;
  _clear_bit(1);
}
inline ::protobuf::Filter_AccessType Filter::accesstype() const {
  return static_cast< ::protobuf::Filter_AccessType >(accesstype_);
}
inline void Filter::set_accesstype(::protobuf::Filter_AccessType value) {
  GOOGLE_DCHECK(::protobuf::Filter_AccessType_IsValid(value));
  _set_bit(1);
  accesstype_ = value;
}

// optional .protobuf.Expression value = 3;
inline bool Filter::has_value() const {
  return _has_bit(2);
}
inline void Filter::clear_value() {
  if (value_ != NULL) value_->::protobuf::Expression::Clear();
  _clear_bit(2);
}
inline const ::protobuf::Expression& Filter::value() const {
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::protobuf::Expression* Filter::mutable_value() {
  _set_bit(2);
  if (value_ == NULL) value_ = new ::protobuf::Expression;
  return value_;
}

// repeated .protobuf.Expression subChildren = 4;
inline int Filter::subchildren_size() const {
  return subchildren_.size();
}
inline void Filter::clear_subchildren() {
  subchildren_.Clear();
}
inline const ::protobuf::Expression& Filter::subchildren(int index) const {
  return subchildren_.Get(index);
}
inline ::protobuf::Expression* Filter::mutable_subchildren(int index) {
  return subchildren_.Mutable(index);
}
inline ::protobuf::Expression* Filter::add_subchildren() {
  return subchildren_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >&
Filter::subchildren() const {
  return subchildren_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >*
Filter::mutable_subchildren() {
  return &subchildren_;
}

// repeated .protobuf.Expression values = 5;
inline int Filter::values_size() const {
  return values_.size();
}
inline void Filter::clear_values() {
  values_.Clear();
}
inline const ::protobuf::Expression& Filter::values(int index) const {
  return values_.Get(index);
}
inline ::protobuf::Expression* Filter::mutable_values(int index) {
  return values_.Mutable(index);
}
inline ::protobuf::Expression* Filter::add_values() {
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >&
Filter::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::Expression >*
Filter::mutable_values() {
  return &values_;
}

// optional bool inFromUser = 6;
inline bool Filter::has_infromuser() const {
  return _has_bit(5);
}
inline void Filter::clear_infromuser() {
  infromuser_ = false;
  _clear_bit(5);
}
inline bool Filter::infromuser() const {
  return infromuser_;
}
inline void Filter::set_infromuser(bool value) {
  _set_bit(5);
  infromuser_ = value;
}

// optional bool isNot = 7;
inline bool Filter::has_isnot() const {
  return _has_bit(6);
}
inline void Filter::clear_isnot() {
  isnot_ = false;
  _clear_bit(6);
}
inline bool Filter::isnot() const {
  return isnot_;
}
inline void Filter::set_isnot(bool value) {
  _set_bit(6);
  isnot_ = value;
}

// -------------------------------------------------------------------

// CommandNode

// optional .protobuf.Put put = 1;
inline bool CommandNode::has_put() const {
  return _has_bit(0);
}
inline void CommandNode::clear_put() {
  if (put_ != NULL) put_->::protobuf::Put::Clear();
  _clear_bit(0);
}
inline const ::protobuf::Put& CommandNode::put() const {
  return put_ != NULL ? *put_ : *default_instance_->put_;
}
inline ::protobuf::Put* CommandNode::mutable_put() {
  _set_bit(0);
  if (put_ == NULL) put_ = new ::protobuf::Put;
  return put_;
}

// optional .protobuf.QueryCommon queryCommon = 2;
inline bool CommandNode::has_querycommon() const {
  return _has_bit(1);
}
inline void CommandNode::clear_querycommon() {
  if (querycommon_ != NULL) querycommon_->::protobuf::QueryCommon::Clear();
  _clear_bit(1);
}
inline const ::protobuf::QueryCommon& CommandNode::querycommon() const {
  return querycommon_ != NULL ? *querycommon_ : *default_instance_->querycommon_;
}
inline ::protobuf::QueryCommon* CommandNode::mutable_querycommon() {
  _set_bit(1);
  if (querycommon_ == NULL) querycommon_ = new ::protobuf::QueryCommon;
  return querycommon_;
}

// -------------------------------------------------------------------

// CommandRequest

// optional bool createNewTransaction = 1;
inline bool CommandRequest::has_createnewtransaction() const {
  return _has_bit(0);
}
inline void CommandRequest::clear_createnewtransaction() {
  createnewtransaction_ = false;
  _clear_bit(0);
}
inline bool CommandRequest::createnewtransaction() const {
  return createnewtransaction_;
}
inline void CommandRequest::set_createnewtransaction(bool value) {
  _set_bit(0);
  createnewtransaction_ = value;
}

// optional int64 transactionSequence = 2;
inline bool CommandRequest::has_transactionsequence() const {
  return _has_bit(1);
}
inline void CommandRequest::clear_transactionsequence() {
  transactionsequence_ = GOOGLE_LONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::int64 CommandRequest::transactionsequence() const {
  return transactionsequence_;
}
inline void CommandRequest::set_transactionsequence(::google::protobuf::int64 value) {
  _set_bit(1);
  transactionsequence_ = value;
}

// optional .protobuf.CommandNode cmdNode = 3;
inline bool CommandRequest::has_cmdnode() const {
  return _has_bit(2);
}
inline void CommandRequest::clear_cmdnode() {
  if (cmdnode_ != NULL) cmdnode_->::protobuf::CommandNode::Clear();
  _clear_bit(2);
}
inline const ::protobuf::CommandNode& CommandRequest::cmdnode() const {
  return cmdnode_ != NULL ? *cmdnode_ : *default_instance_->cmdnode_;
}
inline ::protobuf::CommandNode* CommandRequest::mutable_cmdnode() {
  _set_bit(2);
  if (cmdnode_ == NULL) cmdnode_ = new ::protobuf::CommandNode;
  return cmdnode_;
}

// optional .protobuf.ExtraMsg extramsg = 4;
inline bool CommandRequest::has_extramsg() const {
  return _has_bit(3);
}
inline void CommandRequest::clear_extramsg() {
  if (extramsg_ != NULL) extramsg_->::protobuf::ExtraMsg::Clear();
  _clear_bit(3);
}
inline const ::protobuf::ExtraMsg& CommandRequest::extramsg() const {
  return extramsg_ != NULL ? *extramsg_ : *default_instance_->extramsg_;
}
inline ::protobuf::ExtraMsg* CommandRequest::mutable_extramsg() {
  _set_bit(3);
  if (extramsg_ == NULL) extramsg_ = new ::protobuf::ExtraMsg;
  return extramsg_;
}

// optional int32 fetchSize = 5;
inline bool CommandRequest::has_fetchsize() const {
  return _has_bit(4);
}
inline void CommandRequest::clear_fetchsize() {
  fetchsize_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 CommandRequest::fetchsize() const {
  return fetchsize_;
}
inline void CommandRequest::set_fetchsize(::google::protobuf::int32 value) {
  _set_bit(4);
  fetchsize_ = value;
}

// -------------------------------------------------------------------

// ResultSetRequest

// optional int32 resultSequence = 1;
inline bool ResultSetRequest::has_resultsequence() const {
  return _has_bit(0);
}
inline void ResultSetRequest::clear_resultsequence() {
  resultsequence_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 ResultSetRequest::resultsequence() const {
  return resultsequence_;
}
inline void ResultSetRequest::set_resultsequence(::google::protobuf::int32 value) {
  _set_bit(0);
  resultsequence_ = value;
}

// optional int32 fetchSize = 2;
inline bool ResultSetRequest::has_fetchsize() const {
  return _has_bit(1);
}
inline void ResultSetRequest::clear_fetchsize() {
  fetchsize_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 ResultSetRequest::fetchsize() const {
  return fetchsize_;
}
inline void ResultSetRequest::set_fetchsize(::google::protobuf::int32 value) {
  _set_bit(1);
  fetchsize_ = value;
}

// optional .protobuf.ExtraMsg extramsg = 3;
inline bool ResultSetRequest::has_extramsg() const {
  return _has_bit(2);
}
inline void ResultSetRequest::clear_extramsg() {
  if (extramsg_ != NULL) extramsg_->::protobuf::ExtraMsg::Clear();
  _clear_bit(2);
}
inline const ::protobuf::ExtraMsg& ResultSetRequest::extramsg() const {
  return extramsg_ != NULL ? *extramsg_ : *default_instance_->extramsg_;
}
inline ::protobuf::ExtraMsg* ResultSetRequest::mutable_extramsg() {
  _set_bit(2);
  if (extramsg_ == NULL) extramsg_ = new ::protobuf::ExtraMsg;
  return extramsg_;
}

// -------------------------------------------------------------------

// TransactionRequest

// optional int64 transactionSequence = 1;
inline bool TransactionRequest::has_transactionsequence() const {
  return _has_bit(0);
}
inline void TransactionRequest::clear_transactionsequence() {
  transactionsequence_ = GOOGLE_LONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::int64 TransactionRequest::transactionsequence() const {
  return transactionsequence_;
}
inline void TransactionRequest::set_transactionsequence(::google::protobuf::int64 value) {
  _set_bit(0);
  transactionsequence_ = value;
}

// optional .protobuf.ExtraMsg extramsg = 2;
inline bool TransactionRequest::has_extramsg() const {
  return _has_bit(1);
}
inline void TransactionRequest::clear_extramsg() {
  if (extramsg_ != NULL) extramsg_->::protobuf::ExtraMsg::Clear();
  _clear_bit(1);
}
inline const ::protobuf::ExtraMsg& TransactionRequest::extramsg() const {
  return extramsg_ != NULL ? *extramsg_ : *default_instance_->extramsg_;
}
inline ::protobuf::ExtraMsg* TransactionRequest::mutable_extramsg() {
  _set_bit(1);
  if (extramsg_ == NULL) extramsg_ = new ::protobuf::ExtraMsg;
  return extramsg_;
}

// -------------------------------------------------------------------

// LoginRequest

// optional string user = 1;
inline bool LoginRequest::has_user() const {
  return _has_bit(0);
}
inline void LoginRequest::clear_user() {
  if (user_ != &_default_user_) {
    user_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& LoginRequest::user() const {
  return *user_;
}
inline void LoginRequest::set_user(const ::std::string& value) {
  _set_bit(0);
  if (user_ == &_default_user_) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void LoginRequest::set_user(const char* value) {
  _set_bit(0);
  if (user_ == &_default_user_) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void LoginRequest::set_user(const char* value, size_t size) {
  _set_bit(0);
  if (user_ == &_default_user_) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_user() {
  _set_bit(0);
  if (user_ == &_default_user_) {
    user_ = new ::std::string;
  }
  return user_;
}

// optional string password = 2;
inline bool LoginRequest::has_password() const {
  return _has_bit(1);
}
inline void LoginRequest::clear_password() {
  if (password_ != &_default_password_) {
    password_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& LoginRequest::password() const {
  return *password_;
}
inline void LoginRequest::set_password(const ::std::string& value) {
  _set_bit(1);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginRequest::set_password(const char* value) {
  _set_bit(1);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginRequest::set_password(const char* value, size_t size) {
  _set_bit(1);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_password() {
  _set_bit(1);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  return password_;
}

// optional .protobuf.ExtraMsg extramsg = 3;
inline bool LoginRequest::has_extramsg() const {
  return _has_bit(2);
}
inline void LoginRequest::clear_extramsg() {
  if (extramsg_ != NULL) extramsg_->::protobuf::ExtraMsg::Clear();
  _clear_bit(2);
}
inline const ::protobuf::ExtraMsg& LoginRequest::extramsg() const {
  return extramsg_ != NULL ? *extramsg_ : *default_instance_->extramsg_;
}
inline ::protobuf::ExtraMsg* LoginRequest::mutable_extramsg() {
  _set_bit(2);
  if (extramsg_ == NULL) extramsg_ = new ::protobuf::ExtraMsg;
  return extramsg_;
}

// -------------------------------------------------------------------

// PingRequest

// optional string msg = 1;
inline bool PingRequest::has_msg() const {
  return _has_bit(0);
}
inline void PingRequest::clear_msg() {
  if (msg_ != &_default_msg_) {
    msg_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& PingRequest::msg() const {
  return *msg_;
}
inline void PingRequest::set_msg(const ::std::string& value) {
  _set_bit(0);
  if (msg_ == &_default_msg_) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void PingRequest::set_msg(const char* value) {
  _set_bit(0);
  if (msg_ == &_default_msg_) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void PingRequest::set_msg(const char* value, size_t size) {
  _set_bit(0);
  if (msg_ == &_default_msg_) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PingRequest::mutable_msg() {
  _set_bit(0);
  if (msg_ == &_default_msg_) {
    msg_ = new ::std::string;
  }
  return msg_;
}

// optional .protobuf.ExtraMsg extramsg = 2;
inline bool PingRequest::has_extramsg() const {
  return _has_bit(1);
}
inline void PingRequest::clear_extramsg() {
  if (extramsg_ != NULL) extramsg_->::protobuf::ExtraMsg::Clear();
  _clear_bit(1);
}
inline const ::protobuf::ExtraMsg& PingRequest::extramsg() const {
  return extramsg_ != NULL ? *extramsg_ : *default_instance_->extramsg_;
}
inline ::protobuf::ExtraMsg* PingRequest::mutable_extramsg() {
  _set_bit(1);
  if (extramsg_ == NULL) extramsg_ = new ::protobuf::ExtraMsg;
  return extramsg_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::Column_AGGREGATE_FUNC>() {
  return ::protobuf::Column_AGGREGATE_FUNC_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::Column_ValueType>() {
  return ::protobuf::Column_ValueType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::OrderBy_DIRECTION>() {
  return ::protobuf::OrderBy_DIRECTION_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::QueryCommon_QUERY_CONCURRENCY>() {
  return ::protobuf::QueryCommon_QUERY_CONCURRENCY_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::QueryCommon_PlanType>() {
  return ::protobuf::QueryCommon_PlanType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::QueryCommon_LockModel>() {
  return ::protobuf::QueryCommon_LockModel_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::Put_PUT_TYPE>() {
  return ::protobuf::Put_PUT_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::Filter_AccessType>() {
  return ::protobuf::Filter_AccessType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_commands_2eproto__INCLUDED
